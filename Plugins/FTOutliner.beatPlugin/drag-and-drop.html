<style>

:root{
    --dragging-cursor-color: white;
    --dragging-cursor-color-on-light: blue;
}

.beingDragged{
    opacity: 0.2 !important;
    transform: scale(0.9) !important;

    transition: all 0.2s !important;
}

.indexcards .synopsis.beingDragged{
    opacity: 0.3 !important;
    transform: scale(1) !important;
}

#ghost .synopsis::before{
    display: none;
}

#dropDiv{
    position: relative;
    margin-left: 16px;
    height: 0px;
    width: calc(100% - 1) !important;
    background-color: none;
    border: 1px var(--dragging-cursor-color) solid !important;
    border-radius: 0px !important;

    pointer-events: all !important;

    transition: all 0.2s !important; 

    z-index: 9999 !important;
}

#dropDiv::after{
    height: 40px;
    content: " ";
    width: 100%;
    background: transparent;
    display: block;
    position: absolute;
    bottom: -20px

}

#dropDiv.dropZone{
    height: 0px !important;
    margin-top: 20px;
    margin-bottom: 20px;
    transition: all 0.2s !important;

    pointer-events: all !important;
    z-index: 9999 !important;
}

#dropDiv.synopsisDrag{
    position: relative;
    height: 0;
    margin-top: calc(7px * var(--fontSizeFactor))  !important;
    margin-bottom:  calc(7px * var(--fontSizeFactor))  !important;
    padding: 0 !important;
    margin-left: 11px !important;
    margin-right: 0px !important;
    
    border: 1px var(--dragging-cursor-color-on-light) solid !important;
    color: black !important;

    z-index: 9999 !important;
    overflow: visible !important;

    font-size: calc(11px * var(--fontSizeFactor)) !important;
    font-weight: bold !important;
    line-height: calc(2* 12px * var(--fontSizeFactor)) !important;

    opacity: 1;

    pointer-events: all !important;
}

#dropDiv::before{

    position: absolute;
    content: " ";
    height: 4px;
    width: 4px;
    border: 2px var(--dragging-cursor-color) solid !important;
    border-radius: 50%;
    left: -7px;
    top: -4px;
}

#dropDiv.synopsisDrag::before{
    position: absolute;
    border-color: var(--dragging-cursor-color-on-light) !important;
    left: -7px;
    top: -4px;
}

.indexcards .level1>.sectiontext+.dropZone{
    transform: translateY(calc( -2px - var(--indexCardHeight) + 16px * (var(--fontSizeFactor)))) !important;
    min-width: 200px !important;
}

.ghost {
    position: absolute;
    transform: scale(0.9); 
    opacity: 0.85;    
}

#ghost .isSelected {
    background-image: transparent !important;
}

#ghost .scene::before,
#ghost .arrowForIndexCards {
    display: none;
}

.shrinkToNone{
    transform: scale(0) !important;
    margin: 0px 0px 0px 0px !important;
    border: 0px !important;
    transition: all 0.5s !important;
}

.longerAnimation{
    transition: all 0.5s !important;
}

.level1.mustAnimate{
    transition: all 0.2s !important;
}

.scene.mustAnimate{
    transition: all 0.2s !important;
}

.locateme{
    border: 3px solid red !important;
    background-color: gold !important;
}

</style>

<script>

var previouslyDraggedOverElement = false
var beforeOrAfter, previousBeforeOrAfter
var previousDropZonePosition
var dropTookPlace
var closeBoneyardAfter = false

var sectionLevelDrag

var rangeStart, rangeEnd //selects the text to be moved BEFORE sending to plugin!

var dropDivCloserTimer

var elementBeforeDropDiv

function onDragStart(e) {

    if(weAreCurrentlyEditingText){return}

    e.stopPropagation()
    collapseNote()

    Beat.call("Beat.onTextChangeDisabled = true")
    Beat.call("Beat.onOutlineChangeDisabled = true")
	Beat.call("Beat.onSelectionChangeDisabled = true")

    dropTookPlace = false 
    beforeOrAfter = false
    previousBeforeOrAfter = false
    
	if(!e){ //this is really unlikely to occur
        mylog("returning from onDragStart because no event")
        return}  
        
    mylog("onDragStart: " + e.target.classList)

    //don't drag scene dots in index card mode for sections
    if([...e.target.classList].includes('scene') 
        && indexCardMode
        && ![...e.target.parentNode.classList].includes('isExpanded')){
            Beat.call("Beat.alert('Not allowed', 'Moving scene dots around in this view would be quite insecure and finicky. So no.')")
            return
        }

    //avoid dragging others than the ones you do actually drag
    if(![...e.target.classList].includes('isSelected')){
        deselectAllElements()
        e.target.classList.add('isSelected')
    } 

    //set first and last scene of the bunch
        let selectedScenes = document.querySelectorAll('.isSelected')
        let firstElement = (selectedScenes.length > 0) ? Number(selectedScenes[0].id) : Number(e.target.id)
        let lastElement = (selectedScenes.length > 0) ? Number(selectedScenes[selectedScenes.length-1].id) : Number(e.target.id)

    //now: some logic to stop omitted scenes from moving
        if(outline[firstElement].omitted == 1 || outline[lastElement].omitted == 1){
            e.stopPropagation()
            e.preventDefault()
            deselectAllElements ()
            onDragEnd(e)
            Beat.call("Beat.alert('Please unhide scenes first', 'You are trying to move a block of scenes where the first or last scenes are omitted (hidden).\\n\\nDue to how Fountain handles omission marks this might be open a giant can of worms, so you need to unhide them to move them around.\\n\\nFun fact: Hidden scenes WITHIN a block is fine, as long as the first or last scenes are not.')")
            return
        }

    //Next up: check if we're dragging sections and adjust the selection!
    sectionLevelDrag = false
    if (outline[firstElement].typeAsString == "Section"){
        //if only one is selected:
        if (firstElement == lastElement){
            $id(firstElement).classList.add('isSelected')
            sectionLevelDrag = true
            let thisSectionsDepth = [...$id(firstElement).classList].join(" ")
            thisSectionsDepth = (thisSectionsDepth.match(/level(\d)/))[1]
            // mylog(thisSectionsDepth)
            while (outline[lastElement + 1] && 
                !(outline[lastElement + 1].typeAsString == "Section" && 
                [...$id(lastElement + 1).classList].join(" ").match(/level(\d)/)[1] <= thisSectionsDepth)){
                    lastElement ++
                    a = $id(lastElement)
                    if (a){a.classList.add("isSelected")}
            }
        //but now, if more than one is somewhow selected
        }else{
            for (i = firstElement + 1; i<lastElement; i++){
                if (outline[i].typeAsString == "Section"){
                    e.stopPropagation()
                    e.preventDefault()
                    deselectAllElements ()
                    onDragEnd(e)
                    Beat.call("Beat.alert('Can only move single sequences at a time', 'To move a sequence, grab its sequence header and move all scenes at once.\\n\\nTo move a subset of the sequence select the desired scenes and move them separately.')")
                    return
                }
            }
        }
        //also check if range of selected stuff is not a full section + all contents
        if(outline[lastElement + 1] && outline[lastElement +1].typeAsString != "Section"){
            e.stopPropagation()
            e.preventDefault()
            deselectAllElements ()
            onDragEnd(e)
            Beat.call("Beat.alert('Can only move entire sequences', 'To move a sequence, grab its sequence header and move all scenes at once.\\n\\nTo move a subset of the sequence select the desired scenes and move them separately.')")
            return
        }
    
    //if sectionDrag, we need to re-evaluate selectedScenes again:
        selectedScenes = $$('.isSelected')

    }  

    mylog("past checking if sectionDrag")
              
        if (firstElement != lastElement){

            if (outline[firstElement].typeAsString == "Synopse"){
                    e.stopPropagation()
                    e.preventDefault()
                    deselectAllElements()
                    onDragEnd(e)
                    alertThis('Moving multiple synopsis is not allowed', 'Synopsis can only be moved one by one, so as not to risk splitting screenplay content that may be in between.\\n\\nPlease move synopsis one by one instead.')//, 'Also note that synopsis will intentionally be moved WITHOUT any other screenplay text such as action, dialog, etc.')
                    return   
                }
            
            for (i = firstElement; i < lastElement+1; i++){

                let elementToCheck = $id(i)

                if (outline[i].typeAsString == "Section" && !sectionLevelDrag){
                    e.stopPropagation()
                    e.preventDefault()
                    deselectAllElements ()
                    onDragEnd(e)
                    Beat.call("Beat.alert('Can not move section header as part of selected range', 'Either select the block of scenes you want to move, or grab a section header to move the entire section and everything in it.')")
                    return
                }

                if (!elementToCheck || !elementToCheck.classList.contains("isSelected")){

                    let reasonString = ""

                    if (outline[i].typeAsString == "Synopse"){mylog("synopsis so continuing"); continue}

                    if (outline[i].omitted == 1 && areScenesProportional == 1){reasonString = "It may look as if they are, but the range you are trying to move contains one or more hidden (omitted) scenes, which were not selected. \\n\\nSwitch to non-flexible mode (shortcut: F) to select the entire range."}
            
                    e.stopPropagation()
                    e.preventDefault()
                    deselectAllElements()
                    onDragEnd(e)
                    Beat.call(`Beat.alert('Can only move consequtive scenes!', '` + reasonString + `')`)
                    return
                }
            }
        }

	//remove the you are here indicator before dragging starts for cosmetic reasons
    if($id('youAreHere')){$id('youAreHere').remove()}

    //NOW: Time to start dragging

    previouslyDraggedOverElement = e.target

    $id("flexiContainer").classList.add("drag")

    makeGhost(e, selectedScenes, "dragstart")
    
    //disable hovering of scenes for cosmetic reasons
        let elements = $$(".scene")
        for (element of elements){
            element.classList.add("noHover")
        }

    //un-uglify the ghost image
        elements = $$("#ghost .scene, #ghost .synopsis")
        for (element of elements){
            element.classList.remove("isSelected")
            element.classList.remove("beingDragged")
        }
}

function onDragEnd(e, cancelButton){
	
    mylog("onDragEnd")

    $id("flexiContainer").classList.remove("drag")
    flexiContainer.classList.remove("not-allowed")
    Beat.call(`
        Beat.setSelectedRange(${rangeStart},0)
        `)
    document.getElementById("flexiContainer").classList.add("positionRelative") //for Notes to scroll again -- disabled for Ghost Image
    let allActs = $$(".level1")
        for (act of allActs) act.style.pointerEvents = "none" // makes ACTS unclickable again)

    if (dropTookPlace && !cancelButton){
        mylog("returning from onDragEnd because dropTookPlace")
        return} 
    
    // The rest of this function handles an illegal or cancelled drop (ESC, or wrong place):
    mylog("ESCAPED or ILLEGAL DROP")

    actualChangesToScriptInProgress = false //this is for the errorhandler to know what was happening

    if (document.getElementById("ghost")){document.getElementById("ghost").remove()}
    closeDropZone()

    if (closeBoneyardAfter){$id("flexiContainer").classList.add("boneyardIsClosed")}
    
    let elements = document.querySelectorAll(".scene")
        for (element of elements){
            element.classList.remove("noHover", "beingDragged")       
        }

    elements = document.querySelectorAll(".section")
        for (element of elements){
            element.classList.remove("noHover", "beingDragged") 
        }

    elements = document.querySelectorAll(".synopsis")
        for (element of elements){
            element.classList.remove("noHover", "beingDragged") 
        }

        deselectAllElements()

    Beat.call("Beat.onTextChangeDisabled = false")
    Beat.call("Beat.onOutlineChangeDisabled = false")
	Beat.call("Beat.onSelectionChangeDisabled = false")
}

function onDragEnter(e) {

    e.preventDefault()
    e.stopPropagation()
    
    let draggedOver = e.target
    let draggedFrom = previouslyDraggedOverElement

	mylog("onDragEnter: " + draggedOver.id + " (from " + draggedFrom.id + ")")

    //eliminates error if dragging from outside the plugin
        if(!document.getElementById("ghost")){ 
            mylog("leaving onDragEnter because no #ghost")
            return
        } 

    // first: un-collapse the boneyard if hovering it
        if (draggedOver.classList.contains("boneyard") && $id("flexiContainer").classList.contains("boneyardIsClosed")){
            $id("flexiContainer").classList.remove("boneyardIsClosed")
            closeBoneyardAfter = true
        }

    // setting areas that will keep any active dropDiv alive
        if (draggedOver.id == "dropDiv") return
        if (draggedOver.classList.contains("level1") && !$id("ghost").firstChild.classList.contains("synopsis")) return

    // disallow drop next to the object being dragged
    if ([...draggedOver.classList].includes("beingDragged") || draggedFrom && [...draggedFrom.classList].includes("beingDragged")){
        closeDropZone()
        return
    }
}

function onDragLeave(e) {

    flexiContainer.classList.toggle("not-allowed", false)   

    e.preventDefault()
    e.stopPropagation()

}

function closeDropZone(timer){

    mylog("from " + closeDropZone.caller.name)

    //re-hide expanded synopsiscontainers
        let emptyContainers = $$(".temporarilyShowSynopsisContainer")
        for (let container of emptyContainers){
            container.classList.remove("temporarilyShowSynopsisContainer")
        }

    previousDropZonePosition = false
    previouslyDraggedOverElement = false
    previousBeforeOrAfter = false
    
    if(!$id("dropDiv")) {
        mylog("there was no dropdiv to close, duh")
        return
    }

    if(!timer || timer == 0){clearTimeout(dropDivCloserTimer)}

    dropDivCloserTimer = setTimeout(function() {
        $id("dropDiv").remove()
            //mylog("removal fired and executed")
        }, timer || 0)
    
    mylog("done closing the DropZone")
}

function onDragOver(e) {
    
    e.preventDefault()
    e.stopPropagation()

    // Don't let anything be dragged into FTOutliner from outside
        if(!document.getElementById("ghost")){
            mylog("CANCELLING because no #ghost")
            return
        } 

    let draggedOver = e.target

    // // be generous when draggedover is boneyard
    //     //this allows it to pass the gatekeeper below, 
    //     //but helps only for sections. 
    //     if (draggedOver.classList.contains("boneyard")){
    //         draggedOver = $(".boneyard").lastChild
    //         mylog("changing to lastchild bc dragging over empty boneyard")
    //     }

    // setting areas that will cancel any avtive dropDiv
        if (draggedOver.id == "dropDiv") return 
        //if (draggedOver.classList.contains("level1") && !$id("ghost").firstChild.classList.contains("synopsis")) return

        //fri 13 -- just re-allowed dragging over level1

    //Gatekeeper for synopsis, which will send us away. So all below this statement is NOT synopsis
        if($id("ghost").firstChild.classList.contains("synopsis")){ 
            //if(draggedOver != previouslyDraggedOverElement){
                onDragOverForSynopsis(e, draggedOver, previouslyDraggedOverElement)
                    previouslyDraggedOverElement = draggedOver
                    previousBeforeOrAfter = beforeOrAfter
            //}       
            return
        }

    //Gatekeeper for section, which will send us away. So all below this statement is NOT section either
        if($id("ghost").firstChild.classList.contains("section")){ //gatekeeper for section, all below this line is NOT section
            if(draggedOver != previouslyDraggedOverElement){
                onDragOverForSections(e, draggedOver)
                    previouslyDraggedOverElement = draggedOver
                    previousBeforeOrAfter = beforeOrAfter
            }       
            return
        }

    //Only scenes remain -- so now let's send us away no matter what
        onDragOverForScenes(e, draggedOver)
        previouslyDraggedOverElement = draggedOver
        previousBeforeOrAfter = beforeOrAfter
    
}

function onDragOverForSynopsis(e, draggedOver, previouslyDraggedOverElement){

    mylog ("now: " + draggedOver.classList)
    mylog ("prev: " + previouslyDraggedOverElement?.classList)

    //expand scene dots
    if (draggedOver.classList.contains("scene")&&
        !draggedOver.closest(".section")?.classList.contains("isExpanded") &&
        indexCardMode){
            draggedOver.closest(".section")?.classList.add("isExpanded")
            return
    }

    let theBehavior

    mylog("past let behavior")

    if (draggedOver.classList.contains("synopsiscontainer")){
        theBehavior = "synopsiscontainer"
    }else if (draggedOver.classList.contains("synopsis") 
                && 
            !draggedOver.classList.contains("beingDragged")){
        theBehavior = "synopsis"
    }else if (draggedOver.classList.contains("dropDiv")) {
        return
    }else if (draggedOver.classList.contains("section-heading")
                &&
             draggedOver.closest(".section").classList.contains("collapsedSection")) {
        draggedOver.closest(".section").classList.remove("collapsedSection")
        return
    }else if (draggedOver.classList.contains("scene") || draggedOver.classList.contains("sceneheading")){
        draggedOver.closest(".scene").classList.add("temporarilyShowSynopsisContainer")
        return
    }else{
        closeDropZone()
        return
    }

    if (theBehavior == "synopsiscontainer"){

        mylog("behavior is container")

        if(draggedOver.lastChild?.classList.contains("beingDragged")){
            mylog("disallowing drop in container that ends with dragged synopsis")
            return
        }

        let dropDiv = document.createElement('div')

        dropDiv.id = "dropDiv"
        dropDiv.classList.add("synopsisDrag")
        dropDiv.innerHTML = ""

        if($id("dropDiv")){$id("dropDiv").remove()}

            let closestScene = draggedOver.closest(".scene")?.id || 0
            let closestSection = draggedOver.closest(".section")?.id || 0
            let closestSceneOrSection = Math.max(closestScene, closestSection)
            dropDiv.dataset.insertBeforeScene = Number(draggedOver.lastChild?.id) + 1 || closestSceneOrSection + 1

        closeDropZone()
        draggedOver.appendChild(dropDiv)

        mylog("dropdiv appended as child to container")
    }

    if(theBehavior == "synopsis"){

        mylog("behavior is synopsis")

        beforeOrAfter = "afterend"

            let bounding = draggedOver.getBoundingClientRect()
            let y = e.clientY
                if (y - bounding.top < (bounding.bottom - bounding.top)/2) {beforeOrAfter = "beforebegin"}

        mylog("next up checking siblings")
            
            if (beforeOrAfter == "afterend" && draggedOver.nextSibling?.classList.contains("beingDragged")
                || beforeOrAfter == "beforebegin" && draggedOver.previousSibling?.classList.contains("beingDragged"))
                {
                    mylog("---------------HOVERING SELF")
                    return
                }

        mylog("now lets create: " + beforeOrAfter)
        
        let dropDiv = document.createElement('div')

        dropDiv.id = "dropDiv"
        dropDiv.classList.add("synopsisDrag")
        dropDiv.innerHTML = ""

        if($id("dropDiv")){$id("dropDiv").remove()}


        closeDropZone()
        draggedOver.insertAdjacentElement(beforeOrAfter, dropDiv)

        dropDiv.dataset.insertBeforeScene = Number(draggedOver.id) + 1
        if (beforeOrAfter == "beforebegin"){
            dropDiv.dataset.insertBeforeScene = Number(draggedOver.id)
        }

        mylog("dropdiv appended as sibling " + beforeOrAfter + " of a synopsis")
    }

}

function onDragOverForSections(e, draggedOver){

    mylog ("onDragForSections: " + draggedOver.classList)

    // fri 13 -- reallows level1
    // if (!draggedOver || draggedOver.classList.contains("level1") || draggedOver.classList.contains("flexiContainer")){
    if (!draggedOver || draggedOver.classList.contains("flexiContainer")){
        closeDropZone()
        return
    }

    if (draggedOver.classList.contains("dropDiv")) {
        return
    }else if (!draggedOver.classList.contains("section")){
        draggedOver = draggedOver.closest(".section")
        // fri 13 -- reallows level1
        // if(!draggedOver || draggedOver.classList.contains("level1")){
        if(!draggedOver){
            closeDropZone()
            return
        }
    }

    //disallow dragging an #ACT into the #BONEYARD
    if ($id("ghost").firstChild.classList.contains("level1") && draggedOver.classList.contains("boneyard")){
        flexiContainer.classList.toggle("not-allowed", true)   
        return
    }

    //after or before?
        beforeOrAfter = "afterend"
            let bounding = draggedOver.getBoundingClientRect()
            let y = e.clientY
                if (y - bounding.top < (bounding.bottom - bounding.top)/2) {beforeOrAfter = "beforebegin"}
        
        //don't open dropdiv if dropping next to myself
        if (beforeOrAfter == "afterend" && draggedOver.nextSibling?.classList.contains("beingDragged")
        || beforeOrAfter == "beforebegin" && draggedOver.previousSibling?.classList.contains("beingDragged")
        || draggedOver.classList.contains("beingDragged"))
        {
            mylog("hovering self so returning")
            return
        }
    
    //DROP DIV CREATION!
        mylog("now lets create the DropDiv: " + beforeOrAfter)
        
        let dropDiv = document.createElement('div')

        dropDiv.id = "dropDiv"    
        dropDiv.innerHTML = ""

        if($id("dropDiv")){$id("dropDiv").remove()}

        
    //finding place to insert in outline
        let insertBeforeScene = Number(draggedOver.nextSibling?.id)

        if (!insertBeforeScene){
        insertBeforeScene = Number(draggedOver.id) + 1
            while(outline[insertBeforeScene] && outline[insertBeforeScene].typeAsString != "Section"){
                insertBeforeScene ++
            }
        }

        dropDiv.dataset.insertBeforeScene = insertBeforeScene
            if (beforeOrAfter == "beforebegin"){
                dropDiv.dataset.insertBeforeScene = Number(draggedOver.id)
            }

    //now adjusting everything if draggedOver was level1 (fri 13)
        if(draggedOver.classList.contains("level1")){
            
            // COMMENTED OUT THIS BC IT STOPPED SECTIONS FROM BEING DROPPED AFTER #ACT BEFORE ##SECTION
            // Look out for any side effects!
                // if (draggedOver.querySelector(".scene, .section") && !draggedOver.classList.contains("boneyard")){    
                //     return}
                // // so below this point only applies to empty acts or boneyard
            
            // first correctly store drop index
            dropDiv.dataset.insertBeforeScene = Number(draggedOver.id) + 1
                if (draggedOver.classList.contains("boneyard") && draggedOver.querySelector(".scene, .section")){
                    dropDiv.dataset.insertBeforeScene = outline.length + 1
                    //this only works because boneyard must ALWAYS be last act in outline
                }

            // then: this nicely positions the insertion point
            if (draggedOver.classList.contains("boneyard") && draggedOver.querySelector(".scene, .section")){
                draggedOver = draggedOver.lastChild
            }else{
                draggedOver = draggedOver.querySelector(".section-heading")
            }
            beforeOrAfter = "afterend"


        }


        closeDropZone()
        draggedOver.insertAdjacentElement(beforeOrAfter, dropDiv)
        dropDiv.classList.add("dropZone")

    mylog("dropdiv appended as sibling " + beforeOrAfter + " of a section")
}

function onDragOverForScenes(e, draggedOver){

    mylog ("onDragOverForScenes: " + draggedOver.classList)

    if (draggedOver.classList.contains("dropDiv")) {
        return
    }

    // Gatekeeper to throw out all invalid drop-places
        if (!draggedOver.classList.contains("scene") 
            && 
        !draggedOver.classList.contains("sceneheading")
            && 
        !draggedOver.classList.contains("section-heading")
            &&
        !draggedOver.classList.contains("synopsis")
            &&
        !draggedOver.classList.contains("level1") //re-allows level1 on Fri 13
            &&
        !draggedOver.classList.contains("synopsiscontainer"))
        {
            mylog("the gatekeeper: we hovered an invalid place")
            closeDropZone()
            return
        }

    // One more gatekeeper to avoid dropping above act header
    // removed Fri 13
        // if(draggedOver.classList.contains("section-heading") 
        //     &&
        //     draggedOver.closest(".section").classList.contains("level1")        
        // ){
        //     closeDropZone()
        //     return
        // }


    let hoveringSection = false

    if (draggedOver.classList.contains("synopsis") 
        || draggedOver.classList.contains("synopsiscontainer") ){
            draggedOver = draggedOver.closest(".scene") || draggedOver.closest(".section").querySelector(".section-heading")
    }

    if(draggedOver.classList.contains("section-heading") || draggedOver.classList.contains("boneyard"))
        {
        hoveringSection = true
    }else if (!draggedOver.classList.contains("scene")){
        // try {
            draggedOver = draggedOver.closest(".scene")
        // }catch{
        //     draggedOver = null
        //     closeDropZone(500)
        //     return
        // }
    }

    // if (!draggedOver || draggedOver.classList.contains("level1")){
    // re-allows level1 Fri 13
    if (!draggedOver){
        mylog("no draggedOver")
        // closeDropZone(500)
        closeDropZone()
        return
    }

    //expand scene dots
        if (draggedOver.parentNode?.classList.contains("section") &&
            !draggedOver.parentNode?.classList.contains("level1") &&
            !draggedOver.parentNode?.classList.contains("isExpanded") &&
            indexCardMode){
                draggedOver.closest(".section")?.classList.add("isExpanded")
                return
        }

    mylog("Now setting bounding for what we hover")
    // mylog("which by the way is a " + draggedOver.classList)
    // mylog("and hoveringsection is " + hoveringSection)

    //setting boundings -- simple, unless hovering section

    let bounding = draggedOver.getBoundingClientRect()

        if(hoveringSection && !draggedOver.closest(".section").classList.contains("level1")){
            
            let sectionbounding = {}

            let boundingForHeading = draggedOver.closest(".section").querySelector(".section-heading").getBoundingClientRect()
            sectionbounding.top = boundingForHeading.top
            sectionbounding.bottom = boundingForHeading.bottom

            if(indexCardMode && !draggedOver.closest(".section").classList.contains(".collapsedSection")){

                boundingForContainer = draggedOver.closest(".section").querySelector(".synopsiscontainer").getBoundingClientRect()
                sectionbounding.bottom = boundingForContainer.bottom
            }

            bounding = sectionbounding
        }else if(hoveringSection && draggedOver.closest(".section").classList.contains("level1")){
            draggedOver = draggedOver.closest(".level1")
        }

    //after or before?
        beforeOrAfter = "afterend"
            let y = e.clientY
                if (y - bounding.top < (bounding.bottom - bounding.top)/2) {beforeOrAfter = "beforebegin"}

    
    //don't open dropdiv if dropping next to myself
        if (beforeOrAfter == "afterend" && draggedOver.nextSibling?.classList.contains("beingDragged")
        || beforeOrAfter == "beforebegin" && draggedOver.previousSibling?.classList.contains("beingDragged")
        || draggedOver.classList.contains("beingDragged"))
        {
            mylog("hovering self so returning")
            return
        }

    //DROP DIV CREATION!
        mylog("now lets create the DropDiv: " + beforeOrAfter)
        
        let dropDiv = document.createElement('div')

        dropDiv.id = "dropDiv"    
        dropDiv.innerHTML = ""
            
        if($id("dropDiv")){$id("dropDiv").remove()}
        
    
    //inserting it before next sibling, or in lack thereof parents next sibling! 

    let insertBeforeScene = draggedOver.id //default if beforeOrAfter == beforebegin

    if(draggedOver.classList.contains("scene") && beforeOrAfter == "afterend"){
        insertBeforeScene = draggedOver.nextSibling?.id 
                                ||
                            draggedOver.closest(".section")?.nextSibling?.id
                            //this works for everything except last item before higher-level section
    }
    mylog("post first half: " + insertBeforeScene)

    if (hoveringSection){

        mylog("yes to hovering section[-heading]")

        insertBeforeScene = draggedOver.closest(".section").id

        if (beforeOrAfter == "afterend"){
            
            insertBeforeScene = Number(draggedOver.closest(".section").querySelector(".scene")?.id)
                                    ||
                                Number(draggedOver.closest(".section")?.nextSibling?.id)

            mylog("half way down in if, insertBefore... = " + insertBeforeScene)
        }
    }

    if (!insertBeforeScene) {
                insertBeforeScene = Number(draggedOver.closest(".section").id) + 1
                while(outline[insertBeforeScene] && outline[insertBeforeScene].typeAsString != "Section"){
                    insertBeforeScene ++
                }
    }
    
    mylog("we are here" + draggedOver.classList)
    //now adjusting everything if draggedOver was level1 (fri 13)
    if(draggedOver.classList.contains("level1")){

            if (draggedOver.querySelector(".scene, .section") && !draggedOver.classList.contains("boneyard")){mylog(1); return}
            // so below this point only applies to empty acts, or boneyard regardless
            
            // first correctly store drop index
            insertBeforeScene = Number(draggedOver.id) + 1
                if (draggedOver.classList.contains("boneyard") && draggedOver.querySelector(".scene, .section, .orphanText")){
                    
                    insertBeforeScene = outline.length + 1
                    //this only works because boneyard must ALWAYS be last act in outline
                }

            // then: this nicely positions the insertion point
            // if (draggedOver.classList.contains("boneyard") && draggedOver.querySelector(".scene, .section, .orphanText")){
            if (draggedOver.classList.contains("boneyard") && draggedOver.querySelector(".scene, .section")){
                draggedOver = draggedOver.lastChild.lastChild || draggedOver.lastChild || draggedOver.querySelector(".section-heading")
            }else{
                draggedOver = draggedOver.querySelector(".section-heading")
            }
            beforeOrAfter = "afterend"

            hoveringSection = false //or else adjustments are made before creating the dropdiv
        }

    //inserting the new dropDiv -- waiting until counting siblings to not confuse things!
    if (hoveringSection){
        mylog("if hovering section")
        if(beforeOrAfter == "afterend"){
            closeDropZone()
            draggedOver.querySelector(".synopsiscontainer")?.insertAdjacentElement(beforeOrAfter, dropDiv)
        }else{
            closeDropZone()
            draggedOver.closest(".section")?.insertAdjacentElement(beforeOrAfter, dropDiv)
        }
    }else{
        mylog("else for hovering section")
        closeDropZone()
        mylog(beforeOrAfter + " and " + draggedOver.data + " from " + draggedOver.parentNode.classList + " below " + draggedOver.parentNode.parentNode.classList)
        draggedOver.insertAdjacentElement(beforeOrAfter, dropDiv)
    }

    mylog("next: sibling logic done")

    dropDiv.classList.add("dropZone")
    dropDiv.dataset.insertBeforeScene = insertBeforeScene

    mylog("dropdiv appended as sibling " + beforeOrAfter + " of a scene")
}

function onDrop(e){

    if(!$id("dropDiv")) return

    //End of gatekeeping

    mylog("moveTheScenes(" + e + ")")
    let synopsisDrag = false
    dropTookPlace = true
    
    let selectedScenes = document.querySelectorAll('.beingDragged')

    if (selectedScenes.length == 1 && selectedScenes[0].classList.contains("synopsis")){
        synopsisDrag = true
    }
    mylog("synopsisDrag is " + synopsisDrag)

    // let sceneText = synopsisDrag ? "SYNOPSIS" : "SCENE"

    // let dropMessage = warningsAreOn ? (sceneText +
    //     ((selectedScenes.length > 1)? "S" : "") +
    //     " DROPPED") : ""

    // document.getElementById("dropDiv").innerHTML = dropMessage

    if(!synopsisDrag){

        mylog("inside NOT a synopsisdrag!")

        firstScene = selectedScenes[0].id
        lastScene = selectedScenes[selectedScenes.length - 1].id
            while(outline[Number(lastScene) + 1] && outline[Number(lastScene) + 1].typeAsString == "Synopse"){lastScene++;} //makes sure synopsis is moved with scene
        insertBeforeScene = $id("dropDiv").getAttribute("data-insert-before-scene") // written into dropdiv at creation: dataset.beforeScene
    
    }else{

        mylog("inside else for synopsisDrag")

        firstScene = selectedScenes[0].id
        lastScene = firstScene
        rangeStart = outline[firstScene].sceneStart
        rangeEnd = rangeStart + outline[firstScene].line.string.length + 1

        insertBeforeScene = $id("dropDiv").getAttribute("data-insert-before-scene")
    }
    mylog("insert before" + insertBeforeScene)
    
    actualChangesToScriptInProgress = true //this is for the errorhandler to know what was happening
    weAreChangingColors = true
    
    //new method of sending data: sending explicit range. Still sending "scenes" as a security measure though, in case used in the plugin code.
    Beat.call("Beat.custom.moveScenes(" + firstScene + ", " + lastScene + ", " + insertBeforeScene + ", " + warningsAreOn + "," + rangeStart + "," + rangeEnd + ")")
    rangeStart = false
    rangeEnd = false
}

function ifYesToMove(){ //this is visually-related stuff only and does not alter any actual data 

    mylog("Now shrinking the scenes.")

    let secondClone = document.createElement("div")
    secondClone.id = "clone"
    let tmp = 0
    let cloneName

    let selectedScenes = document.querySelectorAll('.beingDragged')

    mylog("before loop")

    for (scene of selectedScenes){
        if (sectionLevelDrag && scene != selectedScenes[0]){continue}
        scene.classList.add("longerAnimation")
            tmp++; cloneName = "tmp" + tmp
            clone = scene.cloneNode(true)
            clone.id = cloneName
            clone.classList.add("countMeOut") //this is all a convoluted way when preserving open and collapsed sections... phew...
            clone.classList.add("longerAnimation", "shrinkToNone")
            clone.classList.remove("beingDragged", "isSelected")
            document.getElementById("dropDiv").insertAdjacentElement("beforebegin", clone)
            onlyToProvokeAnimation = document.getElementById(cloneName).getBoundingClientRect()         
            document.getElementById(cloneName).classList.remove("shrinkToNone")
        scene.classList.add("shrinkToNone")
    }
    setTimeout(function(){
        for (scene of selectedScenes){
            let redraw = scene.getBoundingClientRect()

            scene.style.opacity = "1"
            scene.style.height = "0"
            scene.style.minHeight = "0"
            scene.style.margin = "0"
        }
        if (closeBoneyardAfter){
            $id("flexiContainer").classList.add("boneyardIsClosed")
            closeBoneyardAfter = false
        }
    },500)

    mylog("after loop")

    closeDropZone()

    if($id("dropDiv")){

        $id("dropDiv").classList.remove("over")
        onlyToProvokeAnimation = $id("dropDiv").getBoundingClientRect()         
        $id("dropDiv").classList.add("longerAnimation")
        $id("dropDiv").classList.remove("dropZone")

    mylog("now remains only to remove ghost")
    }else{mylog("no dropDiv!!!")}

    if(!$id("ghost"))mylog("no ghost!!!")

    document.getElementById("ghost")?.remove()

    

    mylog("done")
}

function makeGhost(e, selectedScenes,icamefrom){

    mylog ("from " + icamefrom + " -- and with so many selected scenes: " + selectedScenes.length)

    $id("flexiContainer").classList.remove("positionRelative") //or else Ghost Image will be invisible
    if($id("ghost")){$id("ghost").remove()}
    let allActs = $$(".level1")
        for (act of allActs) act.style.pointerEvents = "all" // allows ACTS to set boundaries for droppable area (so that dropping on flexicontainer cancels)
    
    //set the ghost image
    let ghost = document.createElement("div")
        ghost.id = "ghost"
        ghost.classList.add("ghost")
        ghost.classList.add("isExpanded")
        ghost.style.top = (window.innerHeight * 2) + "px"
        ghost.style.width = window.getComputedStyle(selectedScenes[0]).getPropertyValue("width")

    //if no selected scenes, make the one dragged selected instead
        //let selectedScenes = document.querySelectorAll('.isSelected')
        if (selectedScenes.length < 1) {selectedScenes = [e.target]}
    
    for (scene of selectedScenes){
        clone = scene.cloneNode(true)
        clone.classList.remove("beingDragged")
        // clone.classList.remove("isSelected")

        if (scene.classList.contains("synopsis") && !scene.style.background){
            clone.style.background = "white"}
                
        if (sectionLevelDrag && scene == e.target){ //selects entire sequence if dragging a section head
            ghost.appendChild(clone)
        }
        else if (!sectionLevelDrag && ([...clone.classList].includes("scene") || [...clone.classList].includes("synopsis") )){
            ghost.appendChild(clone)
        } 
        
        scene.classList.add("beingDragged")
        scene.classList.remove("isSelected")
    }

    mylog("setting range to move")
    //highlight all text affected in move; also determining the correct movable range
    rangeStart = outline[selectedScenes[0].id].sceneStart
    mylog("setting endrange: " + selectedScenes[0].classList + selectedScenes[selectedScenes.length-1].id)
        rangeEnd = outline[selectedScenes[selectedScenes.length-1].id].sceneEnd
        
        mylog("before fixing synopsis range")
        // surely, this must have been broken until now?
        // if([...clone.classList].includes("synopsis") && !sectionLevelDrag){
        if(ghost.firstChild.classList.contains("synopsis")){
            rangeEnd = outline[selectedScenes[selectedScenes.length-1].id].sceneStart + 
            outline[selectedScenes[selectedScenes.length-1].id].line.string.length + 1
        }
        mylog("after fixing synopsis range")
        Beat.call("Beat.scrollTo(" + rangeStart + ")") 		
        Beat.call("Beat.setSelectedRange(" + rangeStart + ", " + (rangeEnd - rangeStart) + ")")

        // This is a debugging tool that will bring the text into the html for evaluation purposes!
            // globalStartTime = new Date()
            Beat.call("Beat.custom.sendTextToHTML(" + rangeStart + "," + rangeEnd+ ")") 
            // Beat.call("Beat.custom.sendTextToHTML()") 

        mylog("past setting ranges")

    
    //create ghost image
    $id("flexiContainer").appendChild(ghost)
    let offsetX = 20 // parseInt(window.getComputedStyle($id("ghost")).getPropertyValue("width")) * 0.9 // /2
    let offsetY = 0 // parseInt(window.getComputedStyle($id("ghost")).getPropertyValue("height")) * 0.9 /2
    mylog("before firstchild if")

    e.dataTransfer.setDragImage(document.getElementById("ghost"), offsetX, offsetY);
    
    mylog("end of ghost function")
}

function receiveText(allText, startIndex, endIndex){

    mylog("receiveText()")

    entireScreenplay = allText
    let selectedScreenplay = allText.substr(startIndex, endIndex-startIndex)
    //globalEndTime = new Date()
    // Beat.log("Sending the entire raw screenplay takes..." + (globalEndTime - globalStartTime) +" ms")

    // Beat.log("this is the string")
    // Beat.log(selectedScreenplay)
    // Beat.log(selectedScreenplay.match(/\n/g))

    //if (debugContainerVisibility != 1){toggleDebugContainer()}
    //debugContainer.innerHTML = allText.substring(rangeStart, rangeEnd).replace("\n","<br/>")

}

</script>