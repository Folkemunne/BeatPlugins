/*

Plugin name: FTOutliner
Description: A Flexible Time Outliner for navigating, structuring and editing your screenplay.
Copyright: Fredrik T Olsson 2021-2022
Version: 1.4
Compatibility: 1.929
Type: Tool
Image: screenshots.jpg

<Description>
<style>
a {
	color: #7ca1e6 !important;
	font-weight: bold !important;
}
</style>
<p>A <b>Flexible Time Outliner</b> for navigating, structuring and editing your screenplay.</p>
<ul>
	<li>Scenes arranged per #act and displayed proportionally to their length in the script</li>
	<li>Notes and markers displayed right in their corresponding place in the outline</li>
	<li>Color, hide or delete scenes via right click context menu</li>
	<li>Drag-and-drop to rearrange scenes or entire sequences</li>
	<li>Track characters by highlighting scenes, or isolate scenes of certain color</li>
	<li>Print your outline (or export to PDF)
	<li><b>NEW!</b> Enhanced, fully editable index card view
	<li><b>NEW!</b> Slide-over Note Panel with all notes in one list
	<li><b>NEW!</b> Boneyard (for storing scenes outside of the script structure)
	<li><b>NEW!</b> Easier-to-navigate menu system
	<li>and lots more...
</ul>
<p>For more info, questions or support visit <a href="https://ftoutliner.webflow.io" target="_default">ftoutliner.webflow.io</a></p>
</Description>

*/ 

// Beat.openConsole()

var backgroundAlreadyRunning = false
var queueOneMoreFullUpdate = false

var css = Beat.assetAsString("outline.css")
var globals = Beat.assetAsString("globals.html")
var template = Beat.assetAsString("outline.html")
var dnd = Beat.assetAsString("drag-and-drop.html")
var dialogs = Beat.assetAsString("dialogs.html")
var charactertracking = Beat.assetAsString("charactertracking.html")
var displaynotes = Beat.assetAsString("displaynotes.html")
var contextmenu = Beat.assetAsString("contextmenu.html")
var editcontent = Beat.assetAsString("editcontent.html")
var addelements = Beat.assetAsString("addelements.html")
var printCSS = Beat.assetAsString("printOutlineCSS.css")
var indexcards = Beat.assetAsString("indexCards.html")
var notepanel = Beat.assetAsString("notepanel.html")
var menu = Beat.assetAsString("menu.html")
var printing = Beat.assetAsString("printing.html")
var thePanelWidth, thePanelHeight, thePanelX, thePanelY
// var storingDefaultsHTML = makeStoringDefaultsDiv()
var allDefaultsHTML = makeStoringDefaultsDiv()
var location, length
var html

var fullUpdateInProgress = false
var smallUpdateInProgress = false

var	html = //storingDefaultsHTML +
	css +
	globals +
	allDefaultsHTML +
	dialogs +
	charactertracking +
	displaynotes +
	contextmenu + 
	indexcards +
	notepanel +
	menu +
	printing +
	editcontent +
	addelements +
	dnd +
	template

var charactersArray, scenesWithCharactersArray
var hackyAbsoluteHeightOfLine = 0 // 0.07195301353931427/2 // VERY HACKY: THIS IS TO ADD ONE EXTRA LINE AT TIMES

var startTime
var midTime1, midTime2, midTime3
var endTime
var endTimes =  []
var dispatchTimes = []
var lineStartTime, linesEndTime, timeSpentCalculatingLines = 0
var paginateStartTime, paginateEndTime, timeSpentPaginatingLines = 0
var runCounter = 0
var runCounterText = 0

var fullTimer = false
var selectionTimer = null

var documentName, documentSubName, documentAuthor

var reallyDelete
var windowTitle = "FTOutliner"

var outlineJustFired

var htmlWindow = Beat.htmlWindow(html, thePanelWidth, thePanelHeight, function(){Beat.end()});
	htmlWindow.setFrame(thePanelX, thePanelY, Math.max(thePanelWidth, 380), thePanelHeight) 

fetchDocumentTitles()

// =======================
// END OF GLOBAL VARIABLES
// =======================

Beat.custom = {};

Beat.custom.reloadCode = function(){

	css = Beat.assetAsString("outline.css")
	globals = Beat.assetAsString("globals.html")
	template = Beat.assetAsString("outline.html")
	dnd = Beat.assetAsString("drag-and-drop.html")
	dialogs = Beat.assetAsString("dialogs.html")
	charactertracking = Beat.assetAsString("charactertracking.html")
	displaynotes = Beat.assetAsString("displaynotes.html")
	contextmenu = Beat.assetAsString("contextmenu.html")
	editcontent = Beat.assetAsString("editcontent.html")
	addelements = Beat.assetAsString("addelements.html")
	printCSS = Beat.assetAsString("printOutlineCSS.css")
	indexcards = Beat.assetAsString("indexCards.html")
	notepanel = Beat.assetAsString("notepanel.html")
	menu = Beat.assetAsString("menu.html")
	printing = Beat.assetAsString("printing.html")

 	//storingDefaultsHTML = makeStoringDefaultsDiv()
	allDefaultsHTML = makeStoringDefaultsDiv()


	html = //storingDefaultsHTML +
	css +
	globals +
	allDefaultsHTML +
	dialogs +
	charactertracking +
	displaynotes +
	contextmenu + 
	indexcards +
	notepanel +
	menu +
	printing +
	editcontent +
	addelements +
	dnd +
	template

	htmlWindow.setHTML(html)
	htmlWindow.setFrame(thePanelX, thePanelY, Math.max(thePanelWidth, 380), thePanelHeight) 
}

Beat.onOutlineChange (function() { 
	//Beat.log("FIRED: onOutlineChange")
	
	outlineJustFired = true
	let jsToRun = `startFullUpdate()`	
	htmlWindow.runJS(jsToRun)

			// PLUGIN: onOutlineChange (THIS FUNCTION) will call...
			// HTMLWINDOW: startFullUpdate, which will call...
			// PLUGIN: beat.custom.updateEntireOutline, 
			//         makeJSON, then
			//         paginateThis, which returns to updateEntireOutline, which will call...
			// HTMLWINDOW: updateEverything

})

Beat.custom.updateEntireOutline = function (location, length, previousOutlineLength) {
	Beat.log("================ Update Entire Outline. Location is: " + location)

	startTime = new Date()

	if (backgroundAlreadyRunning){
		Beat.log("          stopped because background already running! ")
		return}

	fullUpdateInProgress = true		
	let jsToRun = `
		document.getElementById('outOfSyncDiv').style.display = 'block';
		document.getElementById('outOfSyncDiv').classList.add('animate');
		document.getElementById('flexiContainer').classList.add('wait');
		`
		htmlWindow.runJS(jsToRun)

	//Beat.log("location in EntireOutline is: " + location)

	if(!location){
		location = Beat.selectedRange().location
	}
	
	let outlineElements = [...Beat.outline()]
	const paginator = Beat.paginator()
		midTime1 = new Date()

	let json = makeJSON()
		midTime2 = new Date()


	Beat.dispatch(function(){
		Beat.log("          Now entering dispatch")

		backgroundAlreadyRunning = true

		let pagesForElements = []
		let pages

		// let location = Beat.selectedRange().location
		// if (location && Beat.currentParser.lineAtPosition(location).typeAsString() != "Synopse"){
			
		// 	Beat.log("          NOT typing in synopse, so paginating")
	
			try{

				for (scene of outlineElements){
						pagesForElements.push(paginateThis(scene, paginator))
				}
				
				pages = JSON.stringify(pagesForElements)
				
			} catch(e) {
				Beat.dispatch_sync(function(){	
					htmlWindow.runJS(`mylog("There was an ERROR in the background: updateEntireOutline() ` + e + `", true)`)
				})
			}

		// }
		
		Beat.dispatch_sync(function(){	
			Beat.log("          dispatch_sync, runJS")
			
			midTime3 = new Date()
			htmlWindow.runJS("updateEverything(" + json + "," + location + "," + length + "," + pages + "," + Beat.getText().length + ")")
			
			// SPEEDOMETER!
			endTime = new Date()
				Beat.log( "          after paginator: " + (midTime1.getTime() - startTime.getTime()) + " ms")
				Beat.log( "          after json: " + (midTime2.getTime() - startTime.getTime()) + " ms")
				Beat.log( "          Total time: " + (endTime.getTime() - startTime.getTime()) + " ms")

			if(queueOneMoreFullUpdate){
				queueOneMoreFullUpdate = false
				Beat.log("Firing another round due to queued up outline change!")
				Beat.custom.updateEntireOutline()
			}

			backgroundAlreadyRunning = false
			fullUpdateInProgress = false
			
			// BELOW: small update immediately after FULL seems to mitigate anomaly when writing at end-of-scene
			// Reason: during the second that the full update takes to paginate, the outline MAY become offset to
			// the pagination data. UpdateOneScene collects the outline in milliseconds, thus reasonably syncing it
			// to the paginated data. This is not perfect, but seems to be as good as we can get.
			
			outlineJustFired = false
			Beat.custom.updateOnlyOneScene(location, length)
		})
	})
}

Beat.onTextChange(function (location, length) { 
	// Beat.log("FIRED: onTextChange -- location is " + location)

	if(outlineJustFired){Beat.log("OnTextChange was IMMEDIATELY CANCELED"); return}

	if(location){ //check if we are in an outline element and if so disreagard this call
		let outlineDetector = Beat.currentParser.lineAtIndex(location)
		if (outlineDetector.typeAsString() == "Section" 
			|| outlineDetector.typeAsString() == "Heading" 
			|| outlineDetector.typeAsString() == "Synopse"){

			Beat.log("            >>> ENDING onTextChange bc writing in outline")
			return
		}
	}

	if (!fullUpdateInProgress){
		smallUpdateInProgress = true
		htmlWindow.runJS("startSmallUpdate(" + location + "," + length + ", " + "1000" + ", " + JSON.stringify(Beat.currentParser?.sceneAtPosition(location)?.typeAsString()) + ")") 
		//htmlWindow.runJS("startSmallUpdate(" + location + "," + length + ")") 
	}
	
			// PLUGIN: onTextChange (THIS FUNCTION) will call...
			// HTMLWINDOW: startSmallUpdate, which will call...
			// PLUGIN: beat.custom.updateOnlyOneScene, which will call...
			//         makeJSON, then
			//         paginateThis, which returns to updateOnlyOneScene, which will call...
			// HTMLWINDOW: updateOneScene

})

Beat.custom.updateOnlyOneScene = function (location, length) {
	Beat.log("==================== updateOnlyOneScene, location is" + location)
	htmlWindow.runJS("document.getElementById('outOfSyncDiv').classList.add('animate')");
	htmlWindow.runJS("document.getElementById('outOfSyncDiv').style.display = 'block'");
	htmlWindow.runJS("document.getElementById('flexiContainer').classList.add('wait')");

	if(outlineJustFired){Beat.log("CANCELED UPDATE_ONLY_ONE B/C OutlineJustFired"); return}

	if (backgroundAlreadyRunning){
		Beat.log("          CANCELLED UPDATE ONLY ONE B/C BACKGROUND WAS RUNNING!")
		return
	}

	if (location<1000){ //crude way so as not to evaluate when past title page
		
		let a = Beat.currentParser.lineAtPosition(location)
		if (a.isTitlePage){
			fetchDocumentTitles(a.string)
		}
	}

	runCounterText++
	//Beat.log("Only Once Scene is now RUNNING! " + runCounterText)

	let json = makeJSON() 	
	
	let outlineElements = Beat.outline()
	let whichSceneAreWeIn = 0
	while (outlineElements[whichSceneAreWeIn + 1] && outlineElements[whichSceneAreWeIn + 1].sceneStart < location){
		whichSceneAreWeIn ++
	}

	while (outlineElements[whichSceneAreWeIn - 1] && outlineElements[whichSceneAreWeIn].typeAsString() == "Synopse"){whichSceneAreWeIn --} //added to fix static scenes if synopse 21'11'17

	let scene = outlineElements[whichSceneAreWeIn]
	const paginator = Beat.paginator()
	let pages = paginateThis(scene, paginator)
	
	htmlWindow.runJS("updateOneScene(" + json + "," + whichSceneAreWeIn + "," + pages + "," + location + "," + length + "," + Beat.getText().length + ")")
}

Beat.onSelectionChange(function (location, length) {
	
	if (fullUpdateInProgress || smallUpdateInProgress){
		return
	}

    if (selectionTimer) {
        selectionTimer.invalidate()
        selectionTimer = null
    }

    selectionTimer = Beat.timer(0.2, function() {
		htmlWindow.runJS("youAreHere(" + location + "," + length + ", true)") //last value is "positionChangeOnly"
    })
})



function ____________________HELPERS__________(){}

function paginateThis(scene, paginator, content) {

	//Beat.log("PaginateThis") This is the wildest time-suck. How to avoid?

	let fixedPage

	try{

		lineStartTime = new Date ()
		content = Beat.linesForScene(scene)	
		linesEndTime = new Date ()
		timeSpentCalculatingLines += (linesEndTime.getTime() - lineStartTime.getTime())

		//Beat.log("number of lines in content is " + content.length)

		paginateStartTime = new Date ()
		paginator.paginateLines(content)

		paginateEndTime = new Date ()
		timeSpentPaginatingLines += (paginateEndTime.getTime() - paginateStartTime.getTime())

		let pagesToReduceWith = 0
		if (paginator.lastPageHeight > 0){
		pagesToReduceWith = (paginator.numberOfPages < 1)? 0 : 1
		}
		fixedPage = paginator.numberOfPages + paginator.lastPageHeight - pagesToReduceWith

		smallUpdateInProgress = false

		fixedPage += hackyAbsoluteHeightOfLine / 2 //adds a line before each scene. Since removed, and since changed to HALF a line.

	} catch(e) {
		Beat.dispatch_sync(function(){	
			htmlWindow.runJS(`mylog("There was an ERROR in the background: paginatethis() ` + e + `", true)`)
		})
	}

	//Beat.log("End of PaginateThis  -- result was " + fixedPage)
	return fixedPage
}

function makeJSON(){

	let outlineItems = Beat.outlineAsJSON() 
    let json = JSON.stringify(outlineItems)

	// Beat.log(outlineItems)
    return json
}

function titleCaseThis(str) {
	let upper = true;
	let newStr = "";
	for (let i = 0, l = str.length; i < l; i++) {
	  if (str[i] == " ") {
		upper = true;
		  newStr += " ";
		continue;
	  }
	  newStr += upper ? str[i].toUpperCase() : str[i].toLowerCase();
	  upper = false;
	}
	return newStr;
}



function ____________________STORING_STUFF___________________(){}

function makeStoringDefaultsDiv(){

	let userDefault = {}
	let documentSetting = {}

	userDefault.isRealTimeOn = Beat.getUserDefault("realTimeUpdates") || 1
		if(userDefault.isRealTimeOn != 0){userDefault.isRealTimeOn = 1}
	userDefault.warningsAreOn = Beat.getUserDefault("warningsAreOn") || true
		if(userDefault.warningsAreOn != "false"){userDefault.warningsAreOn = true}
	userDefault.colorScheme = `"${Beat.getUserDefault("colorScheme")}"` || `"FTOutliner"`
		if(userDefault.colorScheme != `"Beat"`){userDefault.colorScheme = `"FTOutliner"`}
	userDefault.loggingIsOn = Beat.getUserDefault("loggingIsOn") || false
		if(userDefault.loggingIsOn != "true"){userDefault.loggingIsOn = false}

	userDefault.invertTextOnDark = Beat.getUserDefault("invertTextOnDark")
		if(userDefault.invertTextOnDark != "false"){userDefault.invertTextOnDark = true}


	documentSetting.areScenesProportional = Beat.getDocumentSetting("showProportional") || 1
		if(documentSetting.areScenesProportional != "0"){documentSetting.areScenesProportional = "1"}
	documentSetting.whatAreSceneNumbers = `"${Beat.getDocumentSetting("showNumbers")}"` || "none"
		if(documentSetting.whatAreSceneNumbers !== `"none"` && documentSetting.whatAreSceneNumbers !== `"inline"`){documentSetting.whatAreSceneNumbers = `"none"`}
	documentSetting.whatAreSceneLengths = `"${Beat.getDocumentSetting("showLengths")}"` || "none"
		if(documentSetting.whatAreSceneLengths != `"none"` && documentSetting.whatAreSceneLengths != `"inline"`){documentSetting.whatAreSceneLengths = `"none"`}
	documentSetting.whatArePageNumbers = `"${Beat.getDocumentSetting("showPages")}"` || "none"
		if(documentSetting.whatArePageNumbers != `"none"` && documentSetting.whatArePageNumbers != `"inline"`){documentSetting.whatArePageNumbers = `"none"`}
	documentSetting.oneColumnOutline = Beat.getDocumentSetting("oneColumnOutline") || "0"
		if(documentSetting.oneColumnOutline != "1" && documentSetting.oneColumnOutline != "0"){documentSetting.oneColumnOutline = "0"}
	documentSetting.currentZoomLevel = Number(Beat.getDocumentSetting("currentZoomLevel")) || 1
		if(documentSetting.currentZoomLevel < 0 || documentSetting.currentZoomLevel > 2){documentSetting.currentZoomLevel = 1}

	documentSetting.indexCardMode = Beat.getDocumentSetting("indexCardMode") || false
	documentSetting.indexCardHeight = Number(Beat.getDocumentSetting("indexCardHeight")) || 3
	 	if(documentSetting.indexCardHeight < 0 || documentSetting.indexCardHeight > 20){documentSetting.indexCardHeight = 3}

	documentSetting.cardStateForScenes = "[" + Beat.getDocumentSetting("cardStateForScenes") + "]"|| "[]"
	documentSetting.cardStateForSections = "[" + Beat.getDocumentSetting("cardStateForSections") + "]" || "[]"

	documentSetting.notesAreDisplayed = Beat.getDocumentSetting("notesAreDisplayed") || false
		//if(documentSetting.notesAreDisplayed != true){documentSetting.notesAreDisplayed = false}
	documentSetting.markersAreDisplayed = Beat.getDocumentSetting("markersAreDisplayed") || false
		//if(documentSetting.markersAreDisplayed != true){documentSetting.markersAreDisplayed = false}
	documentSetting.beatsAreDisplayed = Beat.getDocumentSetting("beatsAreDisplayed") || false
		//if(documentSetting.BeatsAreDisplayed != true){documentSetting.BeatsAreDisplayed = false}
	documentSetting.greyonly = Beat.getDocumentSetting("greyonly") || false
	documentSetting.notepanel = Beat.getDocumentSetting("notepanel") || false
	documentSetting.showSynopsisInScenes = Beat.getDocumentSetting("showSynopsisInScenes") || false

	documentSetting.documentName = Beat.getDocumentSetting("documentName") || false
	documentSetting.documentSubName = Beat.getDocumentSetting("documentSubName") || false
	documentSetting.documentAuthor = Beat.getDocumentSetting("documentAuthor") || false
	
	documentSetting.boneyardIsClosed = Beat.getDocumentSetting("boneyardIsClosed") || false

	thePanelWidth = Beat.getDocumentSetting("thePanelWidth");
		if(!thePanelWidth){thePanelWidth = 800}
	thePanelHeight = Beat.getDocumentSetting("thePanelHeight");
		if(!thePanelHeight){thePanelHeight = 800}
	thePanelX = Beat.getDocumentSetting("xposition");
		if(!thePanelX){thePanelX = 0}
	thePanelY = Beat.getDocumentSetting("yposition");
		if(!thePanelY){thePanelY = 0}

	documentSetting.theDocumentsWidth = thePanelWidth
	documentSetting.theDocumentsHeight = thePanelHeight
	documentSetting.theWindowsPositionX = thePanelX
	documentSetting.theWindowsPositionY = thePanelY

	let allDefaults = `<script>
		Beat.call("Beat.log('in HTML: Now exectuing the setting of userDefaults')")

		var userDefault = {
		`

			for([key, value] of Object.entries(userDefault)){
				allDefaults += `
					${key} : ${value},`
			}

		allDefaults += `}
		
		Beat.call("Beat.log('in HTML: Now executing the setting of documentSettings')")

		var documentSetting = {`

			for([key, value] of Object.entries(documentSetting)){
				allDefaults += `
					${key}: ${value},`
			}

		allDefaults += `}
	
		Beat.call("Beat.log('Successfully done')")
		</script>`

	return allDefaults
}

Beat.custom.setFrame = function (theWindowsPositionX, theWindowsPositionY, theDocumentsWidth, theDocumentsHeight){
	htmlWindow.setFrame(theWindowsPositionX, theWindowsPositionY, Math.max(theDocumentsWidth, 380), theDocumentsHeight)
}

Beat.custom.saveWindowSize = function() {
	let a = htmlWindow.getFrame()
	
	Beat.setDocumentSetting('xposition', a.x)
	Beat.setDocumentSetting('yposition', a.y)
	Beat.setDocumentSetting('thePanelHeight', a.height)
	Beat.setDocumentSetting('thePanelWidth', a.width)
}

Beat.custom.limitWidth = function() {

	let a = htmlWindow.getFrame()

	htmlWindow.setFrame(a.x, a.y, 380, a.height)
	htmlWindow.runJS("someoneResizedTheWindow()")

}

function ____________________CHARACTER_TRACKING___________________(){}

Beat.custom.addCharacterClasses = function() {

	let allLines = Beat.lines()
	let allScenes = Beat.scenes()
	charactersArray = []
	let occurrencesForCharacter = []

	for (line of allLines){
		if (line.omitted){continue}
		if (line.typeAsString() == "Character"){
			let name = line.string
			name = name.replace(/^\^/, "")
			name = name.replace(/^@/, "")
			name = name.replace(/\(.*\)/gm, '');
			name = name.replace(/\'/gm, '´');
			name = titleCaseThis(name)
			name = name.trim()
			if (!charactersArray.includes(name)){
				charactersArray.push(name)
				occurrencesForCharacter.push(0)
			}else{
				occurrencesForCharacter[charactersArray.indexOf(name)] ++
			}
		}
	}
	
	let temporarySortingArray = []
	let biggestNumber
	let index
	for (let i = 0; i < occurrencesForCharacter.length; i++){

		biggestNumber = Math.max(...occurrencesForCharacter)
		index = occurrencesForCharacter.indexOf(biggestNumber)
		temporarySortingArray.push(charactersArray[index])
		occurrencesForCharacter[index] = -1
	}

	charactersArray = temporarySortingArray
	scenesWithCharactersArray = []

	// I now have all characters. Time to evaluate scenes.

	const outline = [...Beat.outline()]

	for (scene of allScenes){
		const lines = Beat.linesForScene(scene)
		const sceneNumber = outline.indexOf(scene)//scene.sceneNumber
		let copyOfCharacters = [...charactersArray]
		let charactersInScene = ""

		for (line of lines){

			if (line.omitted){continue}

			if (line.typeAsString() == "Character") {
				let name = line.string
				name = name.replace(/^\^/, "")
				name = name.replace(/^@/, "")
				name = name.replace(/\(.*\)/gm, '');
				name = name.replace(/\'/gm, '´');
				name = name.trim()
				name = titleCaseThis(name)

			 	if (copyOfCharacters.includes(name)){
					copyOfCharacters.splice(copyOfCharacters.indexOf(name), 1)
					let spacelessName = name.replace(/ /g, "_")
					spacelessName = spacelessName.replace(/\'|\"/g, "-")
					charactersInScene += spacelessName + " "
				}
			}
			if (line.typeAsString() == "Action") {
				for (let i=0; i<copyOfCharacters.length; i++){
					let name = copyOfCharacters[i]
					if (line.string.includes(name.replace(/´/g, "'")) || line.string.includes(name.replace(/´/g, "'").toUpperCase())){
						copyOfCharacters.splice(copyOfCharacters.indexOf(name), 1)
						let spacelessName = name.replace(/ /g, "_")
						spacelessName = spacelessName.replace(/\'|\"/g, "-")
						charactersInScene += spacelessName + " "
					}
				}
			}
		}
		scenesWithCharactersArray[sceneNumber]=charactersInScene	
	}	
	htmlWindow.runJS("makeCharacterMenu(" + JSON.stringify(charactersArray) + "," + JSON.stringify(scenesWithCharactersArray) + "); updateFilter()")
}

Beat.custom.reevaluateCharactersForScene = function(outlineNumber, sendToUpdateTrueOrFalse){

	const scene = Beat.outline()[outlineNumber]
	// const sceneNumber = Beat.outline()[outlineNumber].sceneNumber

	const lines = Beat.linesForScene(scene)
	let copyOfCharacters = [...charactersArray]
	let charactersInScene = ""

	for (line of lines){

		if (line.omitted){continue}

		if (line.typeAsString() == "Character") {
			let name = line.string
			name = name.replace(/^\^/, "")
			name = name.replace(/^@/, "")
			name = name.replace(/\(.*\)/gm, '');
			name = name.replace(/\'/gm, '´');
			name = name.trim()
			name = titleCaseThis(name)

			 if (copyOfCharacters.includes(name)){
				copyOfCharacters.splice(copyOfCharacters.indexOf(name), 1)
				let spacelessName = name.replace(/ /g, "_")
				spacelessName = spacelessName.replace(/\'|\"/g, "-")

				charactersInScene += spacelessName + " "
			}
		}
		if (line.typeAsString() == "Action") {
			for (let i=0; i<copyOfCharacters.length; i++){
				let name = copyOfCharacters[i]
				if (line.string.includes(name.replace(/´/g, "'")) || line.string.includes(name.replace(/´/g, "'").toUpperCase())){
					copyOfCharacters.splice(copyOfCharacters.indexOf(name), 1)
					let spacelessName = name.replace(/ /g, "_")
					spacelessName = spacelessName.replace(/\'|\"/g, "-")

					charactersInScene += spacelessName + " "
				}
			}
		}
	}
	// scenesWithCharactersArray[sceneNumber]=charactersInScene
	scenesWithCharactersArray[outlineNumber]=charactersInScene
	if(sendToUpdateTrueOrFalse){htmlWindow.runJS("updateFilter(" + JSON.stringify(scenesWithCharactersArray) + ")")}
}

Beat.custom.changeElementColor = function (elements, newColor){	

	Beat.onTextChangeDisabled = true
	Beat.onOutlineChangeDisabled = true
	Beat.onSelectionChangeDisabled = true

	const allOutlineElements = Beat.outline()
	for (element of elements){
		Beat.setColorForScene(newColor, allOutlineElements[element])
	}

	Beat.onTextChangeDisabled = false
	Beat.onOutlineChangeDisabled = false
	Beat.onSelectionChangeDisabled = false

	//if(!location){
		location = Beat.selectedRange().location
	//}

	htmlWindow.runJS("startSmallUpdate(" + location + ", false, 0)")
}

function ____________________NOTES__________(){}

Beat.custom.collectNotes = function() {
	Beat.log("collecting notes")
	let inTime = new Date()
	let allOutlineElements = [...Beat.outline()]
	let parser = Beat.currentParser 

	Beat.dispatch(function(){

		let note = []
		let marker = []
		let beats = []
		let numberOfStorylines = 0
		let previousStoryLine
		let actualNote = []
		let outlineElementNumber = 0
		let lastElementThatWasScene = 0
		let entry = 0
		let markernumber = 0

		let reg = (/\[\[.*\]\]/)
		
			for (OutlineElement of allOutlineElements){
					let LinesInElement = Beat.linesForScene(OutlineElement)

					if (OutlineElement.typeAsString() != "Synopse"){lastElementThatWasScene = outlineElementNumber}

					// class notesData{
					// 	constructor(position, string) {
					// 		this.outlineElementNumber = lastElementThatWasScene 
					// 		this.position = position
					// 		this.string = string
					// 	}
					// }

					for (line of LinesInElement){

						if (line.typeAsString() == "Synopse" && line.string.toLowerCase().includes("[[color")){continue}

						//first check: inline notes
						if(!line.note && line.string.includes("[[")){
							if(line.typeAsString() != "Heading" && line.typeAsString() != "Section"){
								let result = reg.exec(line.string)
								if (result){
									note[entry] = {}
									let inlineNote = result[0]
									let inlineNoteIndex = result.index || 0												
									//note[entry] = new notesData((line.position + inlineNoteIndex), inlineNote)
									note[entry].outlineElementNumber = lastElementThatWasScene
									note[entry].position = (line.position + inlineNoteIndex)
									note[entry].string = inlineNote
									entry ++
								}
							}
						}

						//second check: full-line notes
						if(line.note) {
							
							//third check: full-line but not starting
							if(!line.string.startsWith("[[")) {
									try{note[entry-1].string += "<br/>" + line.string}
									catch {
										continue
									}
								continue
							}
							
							// note[entry] = new notesData(line.position, line.string)
							note[entry] = {}
							note[entry].outlineElementNumber = lastElementThatWasScene
							note[entry].position = line.position
							note[entry].string = line.string
							entry ++
						}
					}
				outlineElementNumber ++
			}

			// Cycle all notes and put them in different arrays depending on type.
			// (This opens for creating new subsets of notes depending on starting term.)
			for (entry of note){
				if (entry.string.startsWith("[[marker")){
					let stringIntoColor = entry.string.toLowerCase().replace(/\[\[marker:*\s*/, "")
					stringIntoColor = stringIntoColor.match(/^#+[0-9]+|[a-z]*/)
					entry.color = stringIntoColor
					marker.push(entry)
				}else if(entry.string.startsWith("[[beat")){
					let strippedString = entry.string.replace(/\[\[beat\s*/i, "").replace(/\]\]/,"")
					let stringIntoStory = strippedString?.toUpperCase()
					if(strippedString.includes(":")){
						stringIntoStory = strippedString?.match(/^.*:/)[0]?.replace(/:/,"")?.toUpperCase()
					}
						//check if this is an existing storyline
						let thisStoryline = false
						let existingStoryline = false
						for(let prev=0; prev<beats.length; prev++){
							if (stringIntoStory == beats[prev].story){
								thisStoryline = beats[prev].storyline
								existingStoryline = true
								break //breaks out of prev-loop
							}
						}
						if(!existingStoryline){
							numberOfStorylines++
						}
						previousStoryLine = stringIntoStory //now never used, can be scrapped
					let stringIntoContent = strippedString.substring(stringIntoStory.length).replace(/^\s*:\s*/, "")
					entry.storyline = thisStoryline || numberOfStorylines
					entry.story = stringIntoStory || "UNNAMED BEAT"
					entry.content = stringIntoContent
					beats.push(entry)
				}else{
					actualNote.push(entry)
				}
			}

			// Beat.log(JSON.stringify([...actualNote]))
			// Beat.log(JSON.stringify([...marker]))
			// Beat.log(JSON.stringify([...beats]))

			Beat.dispatch_sync(function (){
				let outTime = new Date()
					htmlWindow.runJS("displayNotes(" + JSON.stringify([...actualNote]) + "," + JSON.stringify([...marker]) + "," + JSON.stringify([...beats]) + ")")
			})
	})
}

function ____________________OMITTING_AND_DELETING__________(){}

Beat.custom.omitScene = function(areScenesProportional, scenesToOmit, updatesDisabled) { 

	if (areScenesProportional == 1){
		let plural = (scenesToOmit.length > 1) ? "s" : ""
		Beat.alert("Where did my scene"+plural+" go?", "You are now in Flexible mode, and since omitted scenes literally takes up no space in the finished script, they are invisible in this view.\n\nToggle to non-flexible display (shortcut\xa0F) to see any omitted scenes." )
	}

	const outline = [...Beat.outline()]

	Beat.onTextChangeDisabled = true
	Beat.onOutlineChangeDisabled = true
	Beat.onSelectionChangeDisabled = true

	for (let i=0; i<scenesToOmit.length; i++){

		nextScene = 1
		while (outline[scenesToOmit[i]+nextScene] && outline[scenesToOmit[i]+nextScene].typeAsString() == "Synopse") {
			nextScene ++
		}

		//first: check for any omissions INSIDE the scene we want to omit!
		let omissionInsideScene = false
		if (outline[scenesToOmit[i]].omitted == 0){
			let loopToThisPoint = outline[scenesToOmit[i] + nextScene].line.position - 1 || Beat.getText().length - 1
			let lineLooper = outline[scenesToOmit[i]].line.position
			let parser = Beat.currentParser
			while (lineLooper < loopToThisPoint){
				lineLooper += parser.lineAtPosition(lineLooper).string.length + 1
				if(parser.lineAtPosition(lineLooper).string.includes("*/")){
					omissionInsideScene = true
				}
			}	
		}
		if (omissionInsideScene){
			let headline = "Conflicting omission inside\n" 
			headline += (scenesToOmit.length > 1) ? "": "the scene\n" + outline[scenesToOmit[i]].sceneNumber + ". "
			headline += outline[scenesToOmit[i]].line.cleanedString().toUpperCase() 
			headline += (scenesToOmit.length > 1) ? "\n(currently scene #" + outline[scenesToOmit[i]].sceneNumber + ")":""
			let message = (scenesToOmit.length > 1) ? "One of the scenes": "The scene"  
			message += " you are trying to omit already has an omitted/hidden chunk of text inside it.\n\nDue to how Fountain works, omitting the scene would only work up to the point where that chunk ends.\n\nThis scene is therefore left UN-OMITTED."
			if (scenesToOmit.length > 1){message += "\n\nNOTE: FTOutliner will continue to try with the rest of your selected scenes.\nYou will be notified for every scene where this problem occurs."}
			Beat.alert(headline, message)
			continue
		}

		if (!outline[scenesToOmit[i] + nextScene] || !outline[scenesToOmit[i] + nextScene].omitted){Beat.addString("*/\n\n", (outline[scenesToOmit[i]].position + outline[scenesToOmit[i]].length))}
		if (outline[scenesToOmit[i] + nextScene] && outline[scenesToOmit[i] + nextScene].omitted){
			let parser = Beat.currentParser
			let startMarkerFound = false
			let position = (outline[scenesToOmit[i] + nextScene].line.position - 1)

			while (position > outline[scenesToOmit[i]].position && !startMarkerFound){
				position = parser.lineAtPosition(position).position //puts us at front of line
				
				if (parser.lineAtPosition(position).string.includes("/*")){
					a = parser.lineAtPosition(position).string.replace("/*", "*/\n/*")
					Beat.replaceRange(position, a.length - 3, a)
					startMarkerFound = true
				}
				position--
			}
			if(!startMarkerFound){Beat.alert('Error finding starting point of omitted scene', 'Failed to locate any /* marker BELOW \n\n' + outline[scenesToOmit[i]].sceneNumber + ". " + outline[scenesToOmit[i]].string.toUpperCase() + "\n\nPlease check manually if your script looks as expected, or hit cmd+z for UNDO to return to the state before your latest action.")}

		}
		
		if (!outline[scenesToOmit[i]-1] || !outline[scenesToOmit[i]-1].omitted){Beat.addString("/*\n\n", outline[scenesToOmit[i]].position)}
		if(outline[scenesToOmit[i]-1] && outline[scenesToOmit[i]-1].omitted){
			let parser = Beat.currentParser
			let endMarkerFound = false
			let position = (outline[scenesToOmit[i]].line.position - 1)
			
			while (position > outline[scenesToOmit[i]-1].position && !endMarkerFound){
				position = parser.lineAtPosition(position).position //puts us at front of line
				
				if (parser.lineAtPosition(position).string.includes("*/")){
					a = parser.lineAtPosition(position).string.replace("*/", "*/\n/*")
					Beat.replaceRange(position, a.length - 3, a)
					startMarkerFound = true
				}
				position--
			}
			if(!startMarkerFound){Beat.alert('Error finding end point of omitted scene', 'Failed to locate any */ marker ABOVE \n\n' + outline[scenesToOmit[i]].sceneNumber + ". " + outline[scenesToOmit[i]].string.toUpperCase() + "\n\nPlease check manually if your script looks as expected, or hit cmd+z for UNDO to return to the state before your latest action.")}
		}

		startCheck = outline[scenesToOmit[i]].position
		if (outline[scenesToOmit[i] + nextScene]){
			endCheck = outline[scenesToOmit[i] + nextScene].position
			checkForDoubleBlankLines(endCheck)
		}
		checkForDoubleBlankLines(startCheck)
	}

	if(!updatesDisabled){
		Beat.onTextChangeDisabled = false
		Beat.onOutlineChangeDisabled = false
		Beat.onSelectionChangeDisabled = false

		let jsToRun = "document.getElementById('outOfSyncDiv').classList.add('animate'); " +
			"document.getElementById('outOfSyncDiv').style.display = 'block'; " + 
			"document.getElementById('flexiContainer').classList.add('wait'); " +
			"startSmallUpdate(001)"
		htmlWindow.runJS(jsToRun) //note: used to be startFullUpdate
	}
}

Beat.custom.unOmitScene = function(scenesToUnOmit, updatesDisabled) {

	const outline = [...Beat.outline()]

	Beat.onTextChangeDisabled = true
	Beat.onOutlineChangeDisabled = true
	Beat.onSelectionChangeDisabled = true

	for (let i = 0; i < scenesToUnOmit.length; i++){

		nextScene = 1
		while (outline[scenesToUnOmit[i]+nextScene] && outline[scenesToUnOmit[i]+nextScene].typeAsString() == "Synopse") {
			nextScene ++
		}

		let omittedScene = scenesToUnOmit[i]
			if(!outline[omittedScene].omitted){
				continue}

		let parser = Beat.currentParser
		const position = outline[omittedScene].line.position
		let endMarkerFound = false
		let startMarkerFound = false

		//step ONE: remove the end of the omission if appropriate (or start a new one!)
		//=============================================================================

		let endOfScenePosition = (outline[omittedScene + nextScene]) ? 
			outline[omittedScene + nextScene].line.position - 1 :
			Beat.getText().length	
		endOfScenePosition = parser.lineAtPosition(endOfScenePosition).position // turn last index of line into first index of line instead

		let jumpBack = 0

		//case one: look for closing omission point from next scenes start to this
		while (endOfScenePosition - jumpBack > position && !endMarkerFound){
			
			let line = parser.lineAtPosition(endOfScenePosition - jumpBack).string

			if (line.includes('*/')){

				lineToInsert = line.replace('*/','')
				startOfLine = parser.lineAtPosition(endOfScenePosition - jumpBack).position
				lengthOfLine = parser.lineAtPosition(endOfScenePosition - jumpBack).length
					// if (lineToInsert == '') {
					// lengthOfLine ++}
	
				Beat.replaceRange(startOfLine, lengthOfLine, lineToInsert)
				checkForDoubleBlankLines(startOfLine)
				endMarkerFound = true
			}

			jumpBack = jumpBack + line.length + 1
		}
	
		//case two: no closing point found, but next scene omitted too
		if (!endMarkerFound && outline[omittedScene + nextScene] && outline[omittedScene + nextScene].omitted == 1){
			Beat.addString("/*\n\n", endOfScenePosition + 1)
			checkForDoubleBlankLines(endOfScenePosition + 1)
			endMarkerFound = true
		}

		//step TWO: remove start of omission -- case one: look for starting point up until start of prev scene
		//====================================================================================================

		let line = parser.lineAtPosition(position).string
		jumpBack = 0

		while (!line.includes('/*')){

			jumpBack++
			let lengthOfThatLine = parser.lineAtPosition(position - jumpBack).length
			jumpBack = jumpBack + lengthOfThatLine

			line = parser.lineAtPosition(position - jumpBack).string

			if (position - jumpBack < 0 || position - jumpBack <= outline[omittedScene - 1].line.position || line.includes('*/')){
				break
			}
		}

		if (line.includes('/*')){
			lineToInsert = line.replace('/*','')
			let startOfLine = parser.lineAtPosition(position - jumpBack).position
			let lengthOfLine = parser.lineAtPosition(position - jumpBack).length
				if (lineToInsert == '') {
				lengthOfLine ++}

			Beat.replaceRange(startOfLine, lengthOfLine, lineToInsert)
			checkForDoubleBlankLines(startOfLine)
			startMarkerFound = true

		}else{ 
			
			// case two: No start encountered. Is the previous scene omitted? Then just end omission before this one
			if (outline[omittedScene - 1].omitted == 1){
				Beat.addString("*/\n\n", position)
				checkForDoubleBlankLines(position)
				startMarkerFound = true
			}
		}

		//now a double-check: is no error given but the scene still omitted? Then add end marker before scene. 
		if (startMarkerFound && endMarkerFound && outline[omittedScene].omitted == 1){
			Beat.addString("*/\n",outline[omittedScene].line.position)
		}
	
		if (!startMarkerFound || !endMarkerFound){
			let whatsMissing = (!startMarkerFound && !endMarkerFound) ? "neither " : ""
			whatsMissing += "the "
			whatsMissing += (!startMarkerFound) ? "start " : ""
			whatsMissing += (!startMarkerFound && !endMarkerFound) ? "nor the " : ""
			whatsMissing += (!endMarkerFound) ? "end " : ""
			whatsMissing += "point"
			whatsMissing += (!startMarkerFound && !endMarkerFound) ? "s " : " "
			Beat.alert("Failed to un-omit scene" + outline[omittedScene].sceneNumber, "FTOutliner could not find\n" + whatsMissing + "\nwhen trying to un-omit the scene\n" + outline[omittedScene].string.toUpperCase() + ".\n\nPlease check your script manually to remove the corresponding /* and */ entries.\n\nSorry for the inconvenience, this really shouldn't happen.")
		}
		
	} // ENDING THE LOOP

	if(!updatesDisabled){
		Beat.onTextChangeDisabled = false
		Beat.onOutlineChangeDisabled = false
		Beat.onSelectionChangeDisabled = false

		let jsToRun = "document.getElementById('outOfSyncDiv').classList.add('animate'); " +
			"document.getElementById('outOfSyncDiv').style.display = 'block'; " + 
			"document.getElementById('flexiContainer').classList.add('wait'); " +
			"startFullUpdate()"
		htmlWindow.runJS(jsToRun)
	}
}

Beat.custom.deleteNote = function(location, length) {

	let tmp = Beat.getText()
	if (tmp.substring(location + length -1, location + length) != "\n"){
		Beat.log("Found no CL deleting note")
		if (tmp.substring(location -1, location) != " " || tmp.substring(location + length -1, location + length) != " "){
			Beat.log("Also found no enclosing spaces on both sides")
			length --
		}
	}

	if (tmp.substring(location + length -1, location + length + 1) == "\n\n" 
		&&
		tmp.substring(location -1, location) == "\n"){
			length ++
	}

	Beat.timer(1.75, function(){
		Beat.replaceRange(location, length, '')
	})

}

Beat.custom.deleteSynopsis = function(elementsToDelete, warningsAreOn) {

	const outline = [...Beat.outline()]

	Beat.log('you have sent:' + elementsToDelete + 'elements to delete')

	let deleteMessage = outline[elementsToDelete[elementsToDelete.length-1]].string.toUpperCase()
	if (elementsToDelete.length > 1) {deleteMessage += "\nand " + (elementsToDelete.length - 1) + " more synopsis"}

	if(warningsAreOn){

		reallyDelete = Beat.confirm("You are about to delete the synopsis\n" + deleteMessage + "", "No other script text will be deleted\n\nThe action CAN be undone by hitting cmd+z, but beware that once you keep writing the scene may soon become irretrievably lost forever.\n\nAre you entirely sure?")

		if (!reallyDelete){
			htmlWindow.runJS(`
				undimAllScenes()
				`)
			return
		}
	}

	Beat.onTextChangeDisabled = true
	Beat.onOutlineChangeDisabled = true
	Beat.onSelectionChangeDisabled = true

		for (let j=0; j<elementsToDelete.length; j++){

			theLength = outline[elementsToDelete[j]].line.string.length		
			Beat.replaceRange(outline[elementsToDelete[j]].position, theLength, "")
		
		}
	
		Beat.onTextChangeDisabled = false
		Beat.onOutlineChangeDisabled = false
		Beat.onSelectionChangeDisabled = false

		let jsToRun = "document.getElementById('outOfSyncDiv').classList.add('animate'); " +
			"document.getElementById('outOfSyncDiv').style.display = 'block'; " + 
			"document.getElementById('flexiContainer').classList.add('wait'); " +
			"startFullUpdate()"
		htmlWindow.runJS(jsToRun)
}

Beat.custom.deleteScene = function(elementsToDelete, warningsAreOn) {

	Beat.log("deleteScene()")

	const outline = [...Beat.outline()]

	Beat.log('you have sent:' + elementsToDelete + 'elements to delete')

	let deleteMessage = outline[elementsToDelete[elementsToDelete.length-1]].string.toUpperCase()
	if (elementsToDelete.length > 1) {deleteMessage += "\nand " + (elementsToDelete.length - 1) + " more scenes or sequences"}

	if(warningsAreOn){
	
		reallyDelete = Beat.confirm("You are about to delete \n" + deleteMessage + "\nincluding all contents!", "This action CAN be undone by hitting cmd+z, but beware that once you keep writing the scene may soon become irretrievably lost forever.\n\nAre you entirely sure?")
		
		if (!reallyDelete){
			htmlWindow.runJS(`
				undimAllScenes()
				`)
			return
		}
	}

	Beat.onTextChangeDisabled = true
	Beat.onOutlineChangeDisabled = true
	Beat.onSelectionChangeDisabled = true

		//first: un-omit all scenes to delete + the one after.
		this.unOmitScene(elementsToDelete, true)

		for (let j=0; j<elementsToDelete.length; j++){

			//here check for synopsis
			let nextScene = 1
			let endPosition = false
			while (outline[elementsToDelete[j] + nextScene + 1] && outline[elementsToDelete[j] + nextScene].typeAsString() == "Synopse") {
				nextScene ++
			}

			//unomit next scene to avoid removing /* marker
			let nextSceneIsOmitted = false
			if(outline[elementsToDelete[j] + nextScene] && outline[elementsToDelete[j] + nextScene].omitted){
				Beat.custom.unOmitScene([elementsToDelete[j] + nextScene], true)			
				nextSceneIsOmitted = true
			}

			// NOTE: i in omit-function kills i here! Changed to j

			endPosition = outline[elementsToDelete[j] + nextScene] ? (outline[elementsToDelete[j] + nextScene].position) : Beat.getText().length //moved out from "check for synopsis" loop because un-omitting may change value of position
			let theLength = Math.max((endPosition - outline[elementsToDelete[j]].position), outline[elementsToDelete[j]].length)
			
			Beat.replaceRange(outline[elementsToDelete[j]].position, theLength, "")
		
			if(nextSceneIsOmitted){
				Beat.custom.omitScene(false, [elementsToDelete[j]], true) // and NOT nextScene, because one scene is now removed!
				nextSceneIsOmitted = false
			}
		}

		let jsToRun = "ifYesToDelete();" +
			"document.getElementById('outOfSyncDiv').classList.add('animate'); " +
			"document.getElementById('outOfSyncDiv').style.display = 'block'; " + 
			"document.getElementById('flexiContainer').classList.add('wait'); " +
			"startFullUpdate(500)"
		htmlWindow.runJS(jsToRun)

		Beat.timer(500, function(){
			Beat.onTextChangeDisabled = false
			Beat.onOutlineChangeDisabled = false
			Beat.onSelectionChangeDisabled = false
		})
}

Beat.custom.deleteSection = function(elementsToDelete, warningsAreOn) {

	Beat.log("deleteSection()")

	const outline = [...Beat.outline()]

	Beat.log('you have sent:' + elementsToDelete + 'elements to delete')

	let deleteMessage = outline[elementsToDelete[elementsToDelete.length-1]].string.toUpperCase()
	if (elementsToDelete.length > 1) {deleteMessage += "\nand " + (elementsToDelete.length - 1) + " more sequences"}

	if(warningsAreOn){
	
		reallyDelete = Beat.confirm("You are about to delete the section\n" + deleteMessage + "\nincluding all synopsis inside!", "Scenes (and nested sections) below deleted sections will stay intact.\n\nThis action CAN be undone by hitting cmd+z, but beware that once you keep writing the scene may soon become irretrievably lost forever.\n\nAre you entirely sure?")
		
		if (!reallyDelete){
			htmlWindow.runJS(`
				undimAllScenes()
				`)
			return
		}
	}

	Beat.onTextChangeDisabled = true
	Beat.onOutlineChangeDisabled = true
	Beat.onSelectionChangeDisabled = true

		//first: un-omit all scenes to delete + the one after.
		this.unOmitScene(elementsToDelete, true)

		for (let j=0; j<elementsToDelete.length; j++){

			//here check for synopsis
			let nextScene = 1
			let endPosition = false
			while (outline[elementsToDelete[j] + nextScene + 1] && outline[elementsToDelete[j] + nextScene].typeAsString() == "Synopse") {
				nextScene ++
			}

			//unomit next scene to avoid removing /* marker
			let nextSceneIsOmitted = false
			if(outline[elementsToDelete[j] + nextScene] && outline[elementsToDelete[j] + nextScene].omitted){
				Beat.custom.unOmitScene([elementsToDelete[j] + nextScene], true)			
				nextSceneIsOmitted = true
			}

			// NOTE: i in omit-function kills i here! Changed to j

			endPosition = outline[elementsToDelete[j] + nextScene] ? (outline[elementsToDelete[j] + nextScene].position) : Beat.getText().length //moved out from "check for synopsis" loop because un-omitting may change value of position
			let theLength = Math.max((endPosition - outline[elementsToDelete[j]].position), outline[elementsToDelete[j]].length)
			
			Beat.replaceRange(outline[elementsToDelete[j]].position, theLength - 1, "") //the minus 1 here is to leave a CR or next scene may disappear
		
			if(nextSceneIsOmitted){
				Beat.custom.omitScene(false, [elementsToDelete[j]], true) // and NOT nextScene, because one scene is now removed!
				nextSceneIsOmitted = false
			}
		}
	
		Beat.onTextChangeDisabled = false
		Beat.onOutlineChangeDisabled = false
		Beat.onSelectionChangeDisabled = false

		let jsToRun = "document.getElementById('outOfSyncDiv').classList.add('animate'); " +
			"document.getElementById('outOfSyncDiv').style.display = 'block'; " + 
			"document.getElementById('flexiContainer').classList.add('wait'); " +
			"startFullUpdate()"
		htmlWindow.runJS(jsToRun)
}

Beat.custom.checkBlankLines = function(position){

	//used when calling from HTML
	checkForDoubleBlankLines(position)
}

function checkForDoubleBlankLines(position){

	let parser = Beat.currentParser

	// Beat.alert("now to check for double blank lines")

	for (dbl=0; dbl<15; dbl++){

		let indexOfLineAbove = parser.lineAtPosition(position - 1)?.position
		// let lineAbove = parser.lineAtPosition(indexOfLineAbove)?.string
		let lineAbove = parser.lineAtPosition(indexOfLineAbove)?.typeAsString()
		// let line = parser.lineAtPosition(position)?.string
		let line = parser.lineAtPosition(position)?.typeAsString()

		if (line == "Empty" && lineAbove == "Empty"){
			// Beat.alert("now this")
			Beat.replaceRange(position, 1, "")
		}

		position = indexOfLineAbove
	}
}

Beat.custom.moveScenes = function(firstScene, lastScene, insertBeforeScene, warningsAreOn, startPosition, endPosition){

	const outline = [...Beat.outline()]

	//catch-all to make end of selection not out-of-range
	endPosition = Math.min(endPosition, Beat.getText().length)


	let rangeOfScenes = ""
	let numberOfScenesToMove = 0
	for (scenes = firstScene; scenes<lastScene+1; scenes++){
		if(outline[scenes].typeAsString() == "Synopse"){continue}
		rangeOfScenes +=
		((outline[scenes].sceneNumber != undefined) ? 
			"(" + outline[scenes].sceneNumber + ") " : 
			"") +
			outline[scenes].string.toUpperCase() + "\n" +
			((outline[scenes].sceneNumber == undefined) ? 
			"\ncontaining\n\n" : 
			"")
			numberOfScenesToMove++
	}

	if(outline[firstScene].typeAsString() == "Synopse"){
		warningsAreOn = false
	}

	if(warningsAreOn){
		let reallyMove = Beat.confirm("Verify Move!",
			"\nYou are about to move " + 
			((outline[firstScene].typeAsString() != "Section") ?
				"the scene" 
				: "the section") +
			(((outline[firstScene].typeAsString() != "Section") && numberOfScenesToMove > 1) ? 
				"s" 
				: "") +
			"\n\n" + 
			(((outline[firstScene].typeAsString() != "Section")) ? 
				rangeOfScenes 
				: (outline[firstScene].string.toUpperCase()) + "\n") + 
			((outline[insertBeforeScene]) ? 
				("\nto immediately before\n\n" + 
				(outline[insertBeforeScene].omitted == 1 ? "the omitted scene called \n" 
				: "") +
			(((outline[insertBeforeScene] && outline[insertBeforeScene].typeAsString() == "Heading") 
				? ("(" + outline[insertBeforeScene].sceneNumber + ") ") : "") +
				outline[insertBeforeScene].string.toUpperCase()))
				: "\nto immediately after the last scene of your script.")
			+ 
			"\n\nDo you want to proceed?\n")
		if (!reallyMove) {
			htmlWindow.runJS(`onDragEnd(false, true)`)
			return
		}
	}

	htmlWindow.runJS(`ifYesToMove()`)

	Beat.onTextChangeDisabled = true
	Beat.onOutlineChangeDisabled = true
	Beat.onSelectionChangeDisabled = true

	//even before first: check if we are dropping among omitted scenes!
	let sceneBelowDroppedWasOmitted = (outline[insertBeforeScene] && outline[insertBeforeScene].omitted == 1)
	let theSceneAbove = insertBeforeScene - 1
	while (outline[theSceneAbove] && outline[theSceneAbove]?.typeAsString() == "Synopse"){theSceneAbove --}
	let sceneAboveDroppedWasOmitted = (outline[theSceneAbove]?.omitted == 1)

	if (sceneBelowDroppedWasOmitted){
		this.unOmitScene([insertBeforeScene], true)
	}
	if (sceneAboveDroppedWasOmitted){
		this.unOmitScene([theSceneAbove], true)
	}

	//first check so that we don't break omitted scenes!
	//unomitting and reomitting the scene before will make sure it stays intact.
		if(outline[firstScene - 1] && outline[firstScene - 1].omitted){
			Beat.custom.unOmitScene([firstScene - 1])
			Beat.custom.omitScene(0, [firstScene - 1])
		}
	//then, we need to unomit the scene after, but re-omit it once the scenes are moved
		let firstSceneAfterWasOmitted = false
		if(outline[lastScene + 1] && outline[lastScene + 1].omitted){
			firstSceneAfterWasOmitted = true
			Beat.custom.unOmitScene([lastScene+1])
		}

	//removed check for omitted scenes -- this is now disallowed and will be stopped in html window

		// //now take care of omitted scenes INSIDE the range -- but do it differently:
		// //any scenes other than first and last will just nicely come along. 
		// //so:
		// let firstSceneWasOmitted = false
		// if(outline[firstScene].omitted){
		// 	firstSceneWasOmitted = true
		// 	Beat.custom.unOmitScene([firstScene], true)
		// }

		// let lastSceneWasOmitted = false
		// if((firstScene != lastScene) && outline[lastScene].omitted){
		// 	lastSceneWasOmitted = true
		// 	Beat.custom.unOmitScene([lastScene], true)
		// }

	//removed check for start and end: this is now served as exact values from the caller
		//collect start and end index of text
		//var startPosition = outline[firstScene].position
		//var endPosition = (outline[lastScene+1]) ? outline[lastScene+1].position : Beat.getText().length
	
	//collect insertion point
	var insertionPosition = outline[insertBeforeScene] ? outline[insertBeforeScene].position : Beat.getText().length

    //copy text from that range
	var theTextToMove = Beat.getText().substring(startPosition, endPosition)

	//NOW, re-omit the scene after the range.
	if (firstSceneAfterWasOmitted){
		Beat.custom.omitScene(0, [lastScene+1], true) 
		//NOTE: even if doing this BEFORE moving, it should work fine because we retrieved endPosition already
	}

	//DISABLED -- initial EXTRA SECURITY MEASURE: 
	//let's put the range at end of script
	//surrounded by intromessage and outromessage
		// let introMessage = "/*\n\n!_THE TEXT BELOW IS A BACKUP COPY MADE BY FTOUTLINER._\n\n*It was put here during a move, so that if anything were to go wrong during the operation, the text would remain in the document.*\n*If you encounter this text, it means something did in fact go wrong without the plugin catching it. Please check if the following scene(s) appear elswhere in the script -- if they do you can delete this copy. If not, this is the backup text for you to put where you want it. My sincerest apologies for the inconvenience.*\n\n"
		// let outroMessage = "\n!_END OF BACKUP COPY_\n\n*/"
		// Beat.addString(introMessage + theTextToMove + outroMessage, Beat.getText().length)

	//insert and delete, or delete and insert, depending on wheter move was up or down

	let theNewOutlineNumberForFirstMovedScene
	
	// for (outlineElement of Beat.outline()){
	// 		if (outlineElement.position == insertionPosition) {foundit = true; break}
	// 		theNewOutlineNumberForFirstMovedScene ++
	// 	}

    if (insertionPosition < startPosition) {
		deleteTheOldText()
		addTheTextAtNewPosition()

		theNewOutlineNumberForFirstMovedScene = insertBeforeScene
	}

	if (insertionPosition > endPosition) {
		addTheTextAtNewPosition()
		deleteTheOldText()
		
		theNewOutlineNumberForFirstMovedScene = insertBeforeScene - (lastScene - firstScene) - 1
	}

	// finally (1) time to re-omit first and last scene of range in case they were so.
	// Changed: Not re-omitting scenes because disallowing it instead.	
		// if (firstSceneWasOmitted){
		// 	Beat.custom.omitScene(0, [theNewOutlineNumberForFirstMovedScene], true)
		// }
		// if (lastSceneWasOmitted){
		// 	Beat.custom.omitScene(0, [(theNewOutlineNumberForFirstMovedScene + lastScene - firstScene)] ,true)
		// }

	if (sceneBelowDroppedWasOmitted){
		Beat.custom.omitScene(0, [(theNewOutlineNumberForFirstMovedScene + lastScene - firstScene + 1)] ,true)
	}
	if (sceneAboveDroppedWasOmitted){
		let theSceneAboveInserted = theNewOutlineNumberForFirstMovedScene -1
		while (outline[theSceneAboveInserted].typeAsString() == "Synopse"){theSceneAboveInserted --}
		Beat.custom.omitScene(0, [theSceneAboveInserted], true)
	}

    //finally (2) provoke a full update!

	let jsToRun = "setTimeout(function(){" +
		"document.getElementById('outOfSyncDiv').classList.add('animate'); " +
		"document.getElementById('outOfSyncDiv').style.display = 'block'; " + 
		"document.getElementById('flexiContainer').classList.add('wait'); " +
		"startFullUpdate()},999)" 
		//the 999 delay here is to allow animation to finish

	htmlWindow.runJS(jsToRun)
	
	Beat.timer(1, function() {	//and this delay has the same purpose
		Beat.onTextChangeDisabled = false
		Beat.onOutlineChangeDisabled = false
		Beat.onSelectionChangeDisabled = false
	})
	
	//finally (3) here are some scope-only functions for inserting and deleting.

		function addTheTextAtNewPosition(){

			let parser = Beat.currentParser
			let potentialExtraEmptyFirstLine = ""
			let potentialExtraEmptyLastLine = ""
			// if (parser.lineAtPosition(insertionPosition - 1).string != ""){
			if (parser.lineAtPosition(insertionPosition - 1).typeAsString != "Empty"){
				potentialExtraEmptyFirstLine = "\n"
			}

			while (theTextToMove.concat(potentialExtraEmptyLastLine).substr(theTextToMove.concat(potentialExtraEmptyLastLine).length - 2, 2) != "\n\n"){
				potentialExtraEmptyLastLine += "\n"
			}

			Beat.addString(potentialExtraEmptyFirstLine + theTextToMove + potentialExtraEmptyLastLine, insertionPosition)

			checkForDoubleBlankLines(insertionPosition)
		}

		function deleteTheOldText(){
			Beat.replaceRange(startPosition, endPosition-startPosition, "")
			
			// checkForDoubleBlankLines(startPosition)
		}
}

Beat.custom.reallyQuit = function (noconfirm) {

	let quit = false

	if(!noconfirm){
		quit = Beat.confirm("Do you really want to close FTOutliner?", "All your work is stored in Beat, so no harm done. It's just that it's so easy to hit Escape once too many. That's all.\n\nGo ahead and close?")
	}
	if(quit || noconfirm){
		htmlWindow.close()
	}

}

function ____________________PRINT_AND_EXPORT___________________(){}


Beat.custom.exportThis = function (content, classListOfFlexiContainer) {

	let pathToCSS = `/Users/fredriktolsson/Library/Containers/fi.KAPITAN.Beat/Data/Library/Application Support/Beat/Plugins/FTOutliner.beatPlugin/`

	let	output = `
		<!DOCTYPE html>
		<html>
		<head>
		<link rel="stylesheet" href="`+pathToCSS+`outline.css">
		<link rel="stylesheet" href="`+pathToCSS+`indexCards.html"></link>
		<link rel="stylesheet" href="`+pathToCSS+`charactertracking.html"></link>
		</head>
		<meta charset='UTF-8'>
		<body>`+
		((documentName) ? `<p class="headline">` + documentName.toUpperCase() + `</p>`: ``)
		+
		((documentSubName) ? `<p class="headline2">`+ documentSubName + `</p>`: ``)
		+
		`<div id='flexiContainer' class='` + classListOfFlexiContainer + `' style = "outline: 1px lime solid; height: 80vh !important">` +
		content +
		`</div>
		<p class="footer"><span style="float:right">Created using BEAT and the FTOUTLINER plugin.</span><span style="float:left">Writer: ` + documentAuthor + `</span><br/>
		<span style="opacity: 0.2; float:right">` + new Date() + `</p>
		</body></html>`

	Beat.saveFile("html", function (filePath) {

		Beat.writeToFile(filePath, output)
	 })
	
}


Beat.custom.printThis = function (content, classListOfFlexiContainer) {

	documentName = JSON.parse(Beat.getDocumentSetting("documentName")) || false
	documentSubName = JSON.parse(Beat.getDocumentSetting("documentSubName")) || false
	documentAuthor = JSON.parse(Beat.getDocumentSetting("documentAuthor")) || false

	if (!documentName){
		let message1 = "Print outline without title?"
		let message2 = "FTOutliner could not find the title for your screenplay. Hit cancel to open the settings dialog and enter some info, or OK to print anyway."
		let printAnyway = Beat.confirm(message1, message2)

		if(!printAnyway){
			htmlWindow.runJS("newPrintBox()")
			return
		}
	}

	let	output = /*html*/`
		<!DOCTYPE html>
		<html>
		<meta charset='UTF-8'>
		<body>
		${css}  
		${printCSS}  
		${notepanel} 
			<div id="outerEdge">
				<p class="headline"> ${documentName ? documentName.toUpperCase() : ""} </p>
				<p class="headline2"> ${documentSubName ? documentSubName : ""} </p>
					<div id="flexiContainer" class="${classListOfFlexiContainer}">
						${content} 
					</div>
			<div>
			<p class="footer"><span style="float:right">Created using BEAT and the FTOUTLINER plugin.</span><span style="float:left">${documentAuthor? "Writer: " + documentAuthor : ""}</span><br/>
			<span style="opacity: 0.2; float:right">${new Date()}</p>
		</body>
		</html>
		`

		// never turn this on except for bugging purposes!
		// opens the print-html in a new beat document
		// Beat.newDocument(output)

	Beat.printHTML(output, 
		{
			orientation: "portrait", // default is portrait
			paperSize: "a4" // default SHOULD be document setting
		}, 
			function(){htmlWindow.runJS(`togglePrintMode()`)}
	)		
}

function fetchDocumentTitles (titlePageLine) {

// order of priority: 
// 1st -- check if there are values, because if so they win:

if (titlePageLine && titlePageLine.toLowerCase().startsWith("title:")){
	documentName = titlePageLine.replace(/^title:\s*/i, "").toUpperCase()
}
if (titlePageLine && titlePageLine.toLowerCase().startsWith("credit:")){
	documentSubName = titlePageLine.replace(/^credit:\s*/i, "")
}

setWindowTitle()

}

Beat.custom.setTheWindowTitle = function(){
	setWindowTitle()
}

function setWindowTitle() {

	windowTitle = "FTOutliner"

	if (Beat.getDocumentSetting("documentName")) documentName = (Beat.getDocumentSetting("documentName")) || (Beat.getDocumentSetting("documentName"))
	if (Beat.getDocumentSetting("documentSubName")) documentSubName = (Beat.getDocumentSetting("documentSubName")) || (Beat.getDocumentSetting("documentSubName"))
	if (Beat.getDocumentSetting("documentAuthor")) documentAuthor = (Beat.getDocumentSetting("documentAuthor")) || (Beat.getDocumentSetting("documentAuthor"))

	//This hopefully solves backwards compatibility and manages names whether stringified or not
	if (documentName?.startsWith('"'))documentName = JSON.parse(documentName)
	if (documentSubName?.startsWith('"'))documentSubName = JSON.parse(documentSubName)
	if (documentAuthor?.startsWith('"'))documentAuthor = JSON.parse(documentAuthor)

	if (documentName){windowTitle += " — " + documentName}
	if (documentName && documentSubName){windowTitle += " (" + documentSubName + ")"}
	if (windowTitle){htmlWindow.title = windowTitle}

}

Beat.custom.blinkTheLine = function(start, end, color, textcolor){

	// Beat.alert(start, end)
	//start = Beat.currentParser.lineAtIndex(start).position

	if (start != Beat.currentParser.lineAtIndex(start).position){end --} //removes extra character added to include CR if not full line

	Beat.timer(0.25, function () {
		Beat.textBackgroundHighlight(color, start, end)
		if(textcolor){Beat.textHighlight("#222222", start, end)}
		Beat.timer(0.25, function () {

			Beat.reformatRange(start,end)

			Beat.timer(0.25, function () {
				Beat.textBackgroundHighlight(color, start, end)
				if(textcolor){Beat.textHighlight("#222222", start, end)}
				Beat.timer(0.25, function () {

					Beat.reformatRange(start,end)

					Beat.timer(0.25, function () {
						Beat.textBackgroundHighlight(color, start, end)
						if(textcolor){Beat.textHighlight("#222222", start, end)}
						Beat.timer(0.25, function () {

							Beat.reformatRange(start,end)

						})
					})
				})
			})
		})
	})
	
}

Beat.custom.sendTextToHTML = function(startIndex, endIndex){
	allText = Beat.getText()
	htmlWindow.runJS("receiveText(`" + allText + "`," + startIndex + "," + endIndex + ")")
}

Beat.custom.copyRangeToClipboard = function(ranges){

	let allText = Beat.getText()
	let textToCopy = ""
	ranges = JSON.parse(ranges)
	// Beat.alert(ranges)

	for (range of ranges){

		// Beat.alert(range.start, range.end)

		textToCopy += allText.substring(range.start, range.end) + "\n\n"
	}

	Beat.newDocument(textToCopy)

}