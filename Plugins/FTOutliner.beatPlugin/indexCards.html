

<script>

function expandOrCollapseSections(){
	mylog()

	let allSections = $$(".section")

	mylog("surely we can do that even if no present?")
	mylog(allSections.length)

	let removeIt = false
	if ($(".level2")?.classList.contains("collapsedSection")){removeIt = true}

	for (let section of allSections){
		if (section.classList.contains("level1")){continue}

		if (removeIt){
			section.classList.remove("collapsedSection")
		}else{
			section.classList.add("collapsedSection")
		}
	}

$id("flexiContainer").scrollTo(0, 0)
setButtonForExpandedSections()
recalculateHeights() // in order to scroll back on screen if ending up outside

}



function anArrowWasClicked(theClickedThing, triggeredWithKey){

	mylog()
	if (!theClickedThing)return
	//mylog("this was clicked: " + theClickedThing.classList )

	let closestSectionAbove = theClickedThing.closest(".section")

	if (theClickedThing.classList.contains("sectionArrow")){

		if(!event.altKey && !triggeredWithKey){
			closestSectionAbove.classList.toggle("collapsedSection")
		}else{

			let value = !closestSectionAbove.classList.contains("collapsedSection")
			let sections = $$(".section:not(.level1)")

			for (let section of sections){
				section.classList.toggle("collapsedSection", value)
			}
		}
		setAllButtons()
		return
	}

	if(!event.altKey && !triggeredWithKey){	
			
		if([...closestSectionAbove.classList].includes("isExpanded")){
			closestSectionAbove.classList.remove("isExpanded")
			theClickedThing.classList.remove("expanded")
		}else{
			closestSectionAbove.classList.add("isExpanded")
			theClickedThing.classList.add("expanded")
		}
	}else{

		let doCollapse = [...closestSectionAbove.classList].includes("isExpanded")
			// alertThis(closestSectionAbove.classList, doCollapse)
			
		let sections = $$(".section")
		for(section of sections){
			//if ([...section.classList].includes("level1")){continue}
			if(doCollapse){
				section.classList.remove("isExpanded")
			}else{
				section.classList.add("isExpanded")
			}
		}

		let arrows = $$(".arrowForIndexCards")
		for(arrow of arrows){
			if(doCollapse){
				arrow.classList.remove("expanded")
			}else{
				arrow.classList.add("expanded")
			}
		}

		mylog("going to recalc now")
		$id("flexiContainer").scrollTo(0, 0)
		let timeToWait = doCollapse ? 0 : 300
		setTimeout(function(){
			recalculateHeights() // in order to scroll back on screen if ending up outside
		}, 300)
	}

	setAllButtons()
}


function rememberCardState(){
	mylog()

	if(!outline){return}
	if(outline.length == 0 ){return}

	outlineBeforeUpdate = JSON.parse(JSON.stringify(outline))

	
	// let sections = $$(".section:not(.countMeOut)") //this avoids counting clones of section when dragging-and-dropping. See ifYesToMove()
	let sections = $$(".section:not(.countMeOut, .countMeOut .section)") //this avoids counting clones of section when dragging-and-dropping. See ifYesToMove()
	cardStateForScenes = []
	cardStateForSections = []
	let sectionNumber = 0

	// Beat.call("Beat.alert('"+sections.length+"')")


	for (section of sections){

	// for (let i = 0; i < outlineBeforeUpdate.length; i++){

		// if(outlineBeforeUpdate[i].typeAsString != "Section"){continue}

		// section = $id(sectionNumber)
		
		let a = [...section.classList].includes("isExpanded")
		let b = [...section.classList].includes("collapsedSection")
		//let elementNumber = section.id
		if(a){section.classList.add("noAnimation")}
		if(b){section.classList.add("noAnimation")}
		
		cardStateForScenes[sectionNumber] = a
		cardStateForSections[sectionNumber] = b
		
		sectionNumber ++
	}
	mylog("REMEMBERED THIS MANY CARDSTATES: " + cardStateForScenes.length + "(for this many sections" + sections.length + ")")
}

function makeCardStateEqual(){
	mylog()

	if(!outlineBeforeUpdate || outlineBeforeUpdate.length == 0 || !cardStateForScenes || !cardStateForSections){
		return
	}

	mylog(`at this point, there are ${$$(".section").length} sections on screen`)
	mylog(`and the cardstate arrays are ${cardStateForScenes.length} + ${cardStateForSections.length} long`)

	//first: is the number of sections equal?
	let newSections = []
		for (let num = 0; num < outline.length; num ++) {
			if(outline[num].typeAsString == "Section")
			newSections.push(num)
		}
		
	let oldSections = []
		for (let num = 0; num < outlineBeforeUpdate.length; num ++) {
			if(outlineBeforeUpdate[num].typeAsString == "Section")
			oldSections.push(num)
		}
	
	mylog("created old and new sections, they were: OLD = " + oldSections.length + ", NEW =" + newSections.length)
	mylog("the card states have the lengths: " + cardStateForScenes.length + " and " + cardStateForSections.length)
	

	if (oldSections.length == newSections.length){

		mylog("decided they were equally long")

		let forwardMismatch = false
		let backwardMismatch = false
		
		for (let i = 0; i < newSections.length; i ++){
			
			//mylog ("walking thru matching stuff " + i)

			if(outline[newSections[i]].string == outlineBeforeUpdate[oldSections[i]].string){ //reasonably unchanged element
				//mylog("match!")
				continue
			}else{
				forwardMismatch = i
				mylog ("found a mismatch going forward")
				break
			}
		}

		if(forwardMismatch){
			mylog("so now comparing from the back")
			for (let i = newSections.length - 1; i >= forwardMismatch; i --){
				
				//mylog("we're walking again...")

				if(outline[newSections[i]].string == outlineBeforeUpdate[oldSections[i]].string){ //reasonably unchanged element
					continue
				}else{
					backwardMismatch = i
					mylog ("and found one going backward too")
					break
				}
			}
		}
		
		if (!forwardMismatch || forwardMismatch == backwardMismatch) {
			//this just means a section was renamed, so all is well. 
			//return and use the saved values as is.
			mylog("We decided either nothing changed, or it's probably just a renamed section")
			outlineBeforeUpdate = JSON.parse(JSON.stringify(outline))
			return

		}else{

			//this means one or more sections have been shuffled around.
			//let's compare and give old values to sections in their new places

			mylog("does this cause error if moving last scene?")

				let forwardMove
					for (i = forwardMismatch; i < outline.length; i ++){

						if (outline[newSections[i]]?.string == outlineBeforeUpdate[oldSections[forwardMismatch]]?.string){
							forwardMove = i - forwardMismatch
							break
						}
					}
				let numberOfSections = 1
					while (outline[newSections[i + numberOfSections]]?.string == outlineBeforeUpdate[oldSections[forwardMismatch + numberOfSections]]?.string){
						numberOfSections ++
						//fixed an error above with the conditional questionmark, but will this kill something?
				}
				
				for (i = forwardMismatch; i < forwardMismatch + numberOfSections; i++ ){					
					scenevalue = cardStateForScenes[i]
					sectionvalue = cardStateForSections[i]

					cardStateForScenes.splice(i + forwardMove + numberOfSections, 0, scenevalue)
					cardStateForSections.splice(i + forwardMove + numberOfSections, 0, sectionvalue)
				}
				cardStateForScenes.splice(forwardMismatch, numberOfSections)
				cardStateForSections.splice(forwardMismatch, numberOfSections)

			outlineBeforeUpdate = JSON.parse(JSON.stringify(outline))
			return
		}
	}

	mylog("from here remains math if a section was either added or removed. (they could be more than one if made from the doc!")
	//from here remains math if a section was either added or removed. 
	//NOTE: they could be more than one if made by pasting or selecting a chunk and deleting in the doc window
	//that is still not fixed!

	if (newSections.length < oldSections.length){

		// a section was deleted. Find it:

		let forwardMismatch = false
		
		for (let i = 0; i < newSections.length; i ++){
			
			//mylog ("walking thru matching stuff in mismatching outlines" + i)

			if(outline[newSections[i]].string == outlineBeforeUpdate[oldSections[i]].string){ //reasonably unchanged element
				continue
			}else{
				forwardMismatch = i
				mylog ("found a mismatch going forward")
				break
			}
		}

		cardStateForScenes.splice(forwardMismatch, 1) //remove it
		cardStateForSections.splice(forwardMismatch, 1) //remove it
	}

	if (newSections.length > oldSections.length){

		mylog("a section was inserted, because old length was " + oldSections.length + " Find it:")
		// a section was inserted. Find it:

		let forwardMismatch = false

		for (let i = 0; i < newSections.length; i ++){
		
			//mylog ("walking thru matching stuff in mismatching outlines" + i)

			if(outline[newSections[i]].string == outlineBeforeUpdate[oldSections[i]]?.string){ //reasonably unchanged element
				continue
			}else{
				forwardMismatch = i
				mylog ("found a mismatch going forward")
				break
			}
		}
		
		mylog("BEFORE SPLICING: " + newSections.length + " > " + cardStateForScenes.length)

		cardStateForScenes.splice(forwardMismatch, 0, true) //insert it
		cardStateForSections.splice(forwardMismatch, 0, false) //insert it

		mylog("SHOULD BE DONE: " + newSections.length + " == " + cardStateForScenes.length)
	}

	outlineBeforeUpdate = JSON.parse(JSON.stringify(outline))
	return

}

function recallCardState(){

	mylog()
	mylog("when we get here, there are " + $$(".section").length + " sections in the document.") 
	mylog("The cardstates are this long: " + cardStateForScenes.length + " and " + cardStateForSections.length)
	
	if(!outlineBeforeUpdate || outlineBeforeUpdate.length == 0){
		
		if (cardStateForScenes.length == 0){ // so as to run on first run even if no previous outline
		// return
		// }else{
			// this sets All scenes open + All sections closed if opening file without saved defaults
			
			let sections = $$(".section")
			let i = 0
			for (section of sections){
				// section.classList.add("isExpanded")
				// section.classList.add("collapsedSection")
				cardStateForScenes.push(true)
				cardStateForSections.push(true)
				i ++
			}
		}else{
			mylog("so this happened: there is no outlineBeforeUpdate, so this is first run")
			mylog("the length of the two cardstates are..." + cardStateForScenes.length + " and " + cardStateForSections.length)
		}
	}

	if(outlineBeforeUpdate.length > 0){
		makeCardStateEqual()
	}
				
	let sections = $$(".section")
	mylog("and the number of sections is " + sections.length)

	if (sections.length != cardStateForScenes.length ||
		sections.length != cardStateForSections.length){
			mylog("this shouldn't happen, but cardState... & number of sections differ!")
		return
	}

	let allStuff = $$(".synopsiscontainer, .scene")
	for (stuff of allStuff){
		stuff.classList.add("noAnimation")
		let redraw = stuff.getBoundingClientRect()
	}

		for (let i = 0; i < sections.length; i++){

			if (cardStateForScenes[i] == true){
				sections[i].classList.add("isExpanded")
			}
			if (cardStateForSections[i] == true){
				sections[i].classList.add("collapsedSection")
			}		
		}

	allStuff = $$(".synopsiscontainer, .scene")
	for (stuff of allStuff){
		stuff.classList.remove("noAnimation")
		let redraw = stuff.getBoundingClientRect()
	}
	
	mylog("end of recall state")

}

</script>